[ { "title": "Atcoder Beginner Contest 399 후기", "url": "/posts/abc-399/", "categories": "atcoder", "tags": "atcoder, 문제풀이", "date": "2025-03-30 19:00:00 +0900", "snippet": "개요대회 링크어제 (03/29) 저녁 9시부터 10시 40분까지 진행된 Atcoder Beginner Contest 399 후기입니다.총 7문제 중 4문제를 풀었습니다.A번부터 D번까지 풀이하는데 19분을 소모했습니다.이후 E번과 F번을 풀기 위해서 대회 종료시각까지 트라이를 했지만 풀이하지 못했습니다.rating이 떨어지나 걱정했지만, 다행히도 rating이 약간 올라서 안심했습니다.공식 에디토리얼 (해설)풀이 해설은 꼭 문제를 한번 읽고 확인해주세요.A - Hamming Distance문제 내용두 문자열이 주어진다.두 문자열의 해밍 거리 (서로 다른 문자의 개수)를 구하면 된다.풀이문자열을 순회하면서 서로 다른 문자의 개수를 구하면 됩니다.B - Ranking with Ties문제 내용N 개의 score가 주어집니다.각 score마다 RANK() 를 구하면 됩니다. (sql의 RANK()와 같이)풀이정렬을 사용하거나, map을 사용하거나 기타 등등 RANK()를 구현하기만 하면 됩니다.C - Make it Forest문제 내용무향 그래프 F가 주어집니다.간선을 지워 cycle이 없는 그래프가 만드려고 합니다. 이때, 지워야 하는 간선의 최소 개수를 구해야 합니다.풀이처음에 이렇게 풀어도 되는건가? 좀 헷갈렸다.몇 가지 그래프를 그리다보니 확신을 하게 되었고, 아래와 같이 구성을 했다.1 ~ N 까지 정점을 탐색하는데, 각 정점이 방문되지 않은 경우 DFS 탐색을 한다.그리고, 만약 이전에 방문했음에도 다시 방문하게 되면 카운팅한다. 단, 부모로 다시 탐색을 하러 돌아가는 경우는 배제해야 한다.D - Bonfire문제 내용같은 숫자임에도 서로 인접하지 않은 두 숫자를 고른다.두 숫자의 위치를 서로 바꾸어봤을 때, 각 숫자가 인접하게 된다면 카운팅한다.풀이솔직히 이 문제가 D번이 맞나? 싶었다.생각보다 너무 쉽게 풀리는 문제였다.그냥 각 숫자마다 위치 2개를 따로 hash 또는 배열에 저장해둔다.그리고 앞에서부터 순회하면서 인접한 두 숫자에 대해서 저장해둔 위치로 조건을 판단해보면 된다.E - Replace문제 내용문자열 S와 T가 주어진다.문자열 S를 T로 바꾸길 원한다.다만, 문자열 S에 존재하는 임의의 문자를 모두 하나의 문자로 바꾸는 연산만 가능한 상황이다.이때, S를 T로 바꾸는 것이 가능한지, 가능하다면 최소 연산의 수가 어떻게 되는지 구해야 한다.풀이결국 풀이하지 못한 채로 대회가 종료되었다.내 접근은 S-&amp;gt;T로 가기 위한 과정을 유향 그래프화 시키는 것이었다.만약 ab -&amp;gt; cb 라면 a -&amp;gt; c 라는 간선을 추가하는 것처럼 말이다.이 과정에서 cycle이 없다면 간선의 수가 답이었고, cycle이 있다면 cycle로 변하는 과정에서 임의의 temp 문자로 변환되었다가 맨마지막에 변환되는 식이 되지 않을까 해서 간선의 수 + 1 을 더하는 방식이었다.다만 이 과정을 구하는게 까다로웠고, 현재 temp 문자로 사용할 수 있는 문자가 있는지 등을 체크하기 위해 SCC와 위상정렬을 막 적용하다가 시간이 끝났다…결론7문제 중 4문제를 풀이하고 끝나서 굉장히 찝찝한 contest였다.트리나 그래프 문제가 나오면 아직도 망설임이 좀 있는 것 같다. 관련 문제와 아이디어들을 좀 더 접할 필요가 있는 것 같다." }, { "title": "Atcoder Beginner Contest 398 후기", "url": "/posts/abc-398/", "categories": "atcoder", "tags": "atcoder, 문제풀이", "date": "2025-03-23 11:20:00 +0900", "snippet": "개요대회 링크어제 (03/22) 저녁 9시부터 10시 40분까지 진행된 Atcoder Beginner Contest 398 후기입니다.총 7문제 중 6문제를 풀었습니다.A번부터 D번까지 풀이하는데 20분을 소모했고,E번이 interactive 문제였고, 아이디어가 떠오르지 않아 F번 먼저 풀이하였고 이때 20분 정도 시간이 걸렸습니다.그 이후, E번 풀이를 떠올리고 풀이하는데 25분 가량 걸렸습니다. 그리고도 시간이 남아서 G번을 확인하였습니다.다만, 이때까지도 모든 문제를 풀이한 사람이 없던 상황이었고, G번의 난이도가 쉽지 않다는 것을 알게 되었습니다.여러 접근을 했지만 풀이를 알아내지 못하고 대회가 종료되었습니다.공식 에디토리얼 (해설)풀이 해설은 꼭 문제를 한번 읽고 확인해주세요.A - Doors in the Center 문제 내용- 와 = 로 구성된 팰린드롬 문자열을 만드는 문제이다.풀이주어지는 N이 홀수인지, 짝수인지에 따라 문자열을 구성하면 된다.B - Full House 3문제 내용7개의 숫자가 주어진다. 이 숫자를 조합하여 풀하우스를 만들 수 있는지 구하면 된다.풀이서로 다른 숫자 a, b에 대해, a의 개수는 3개 이상, b의 개수는 2개 이상인지 검사하면 된다.ㄴC - Uniqueness문제 내용1 ~ N 번 사람이 각자 숫자를 가지고 있다.다른 사람들이 가지고 있지 않는 사람들 중에, 가지고 있는 숫자가 가장 큰 사람의 번호를 반환해야 한다.풀이솔직히 지문을 읽고, 뭔 이상한 소리인가 싶었고, 예제 또한 이상하게 주어져있어서 조금 당황했다.discussion에서 다른 사람들도 헷갈릴 여지가 있었던 것으로 보인다.위에 문제 내용을 그대로 구현하면 된다.D - Bonfire문제 내용모닥불에서 연기가 생성된다.각 시간(틱)마다 바람이 분다. 이때 특정 (R, C)에 있는 사람에게 연기가 닿았는지 확인하여 모든 시간마다의 결과를 출력한다.풀이원래라면 모닥불로 하여금 생긴 연기를 계속 움직여가며 판단할 수 있다.하지만 연기의 최대 개수가 200,000 개 이기 때문에 N^2이 되는 순간 해결할 수가 없다.그래서 문제를 보자마자 바로 구현하기 시작한건 연기를 고정시키고 모닥불(0, 0)과 사람 (R, C)을 계속 이동시키자였다.아래와 같이 구현했다. 다만 좌표를 저장할때 특정 int value로 담아두고 싶어서 좌표를 변환하여 했다. 지금 생각해보면 그냥 tuple로 저장해도 되었을 텐데라는 아쉬움이 남는다.DIFF = 400000K = 10000000def to_axis(y, x): return y * K + xdef solve(): n, r, c = mii() s = inp() maker = [DIFF, DIFF] dy = { &#39;N&#39;: 1, &#39;S&#39;: -1, &#39;W&#39;: 0, &#39;E&#39;: 0 } dx = { &#39;N&#39;: 0, &#39;S&#39;: 0, &#39;W&#39;: 1, &#39;E&#39;: -1 } r += DIFF c += DIFF smokes = {} ans = &quot;&quot; for i in range(n): direction = s[i] axis = to_axis(*maker) smokes[axis] = True maker[0] += dy[direction] maker[1] += dx[direction] r += dy[direction] c += dx[direction] if smokes.get(to_axis(r, c), False): ans += &quot;1&quot; else: ans += &quot;0&quot; print(ans)E - Tree Game문제 내용트리가 주어진다. 이때 트리에 간선을 추가하는 액션을 각 턴마다 진행한다.단, 간선을 추가함으로서 홀수개의 노드로 구성된 cycle이 생기면 안된다.더이상 추가할 수 있는 간선이 없는 경우 패배한다.상대와 게임을 진행함에 있어서, 선공/후공을 정하여 승리해야 한다.풀이처음에는 인터랙티브 문제이기도 하고 풀이가 잘 떠오르지 않았다.그러던 중 예시를 여러 개 만들어보다가 떠오른 생각이 있었다.처음에 주어지는 트리 상에서, 서로의 거리가 홀수로 떨어져 있는 경우면서 바로 이어지지 않은 경우가 결국 간선을 만들어낼 수 있는 경우 아닌가?정점의 개수 N이 최대 100까지였기 때문에 구현을 빠르고 쉽게하기 위해, 플로이드-와샬로 미리 거리를 구했고,서로의 거리가 홀수로 떨어져 있는 경우면서 바로 이어지지 않은 경우 == ar[x][y] % 2 == 1 &amp;amp;&amp;amp; ar[x][y] &amp;gt; 1에 대한 간선을 미리 구해두었다.그래서 이 간선들을 토대로 내 턴에는 아무거나 출력하고, 상대 턴에는 주어지는 간선을 제거하면서 처리해봤다.ll ar[110][110];void solve() { ll N; cin &amp;gt;&amp;gt; N; for(int i = 0; i &amp;lt;= N; i++) { for(int j = 0; j &amp;lt;= N; j++) { ar[i][j] = INF; } ar[i][i] = 0; } for(int i = 1; i &amp;lt; N; i++) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; ar[a][b] = 1; ar[b][a] = 1; } for(int z = 1; z &amp;lt;= N; z++) { for(int x = 1; x &amp;lt;= N; x++) { for(int y = 1; y &amp;lt;= N; y++) { if(ar[x][y] &amp;gt; ar[x][z] + ar[z][y]) { ar[x][y] = ar[x][z] + ar[z][y]; } } } } vector &amp;lt;pii&amp;gt; ans_list; for(int x = 1; x &amp;lt;= N; x++) { for(int y = x + 1; y &amp;lt;= N; y++) { if(ar[x][y] % 2 == 1 &amp;amp;&amp;amp; ar[x][y] &amp;gt; 1) ans_list.push_back({ x, y }); } } if(ans_list.size() % 2 == 0) { cout &amp;lt;&amp;lt; &quot;Second&quot; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &quot;First&quot; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; ans_list[0].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ans_list[0].second &amp;lt;&amp;lt; endl; ans_list.erase(ans_list.begin()); } while(1) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; if(a == -1 &amp;amp;&amp;amp; b == -1) return; if (a &amp;gt; b) { swap(a, b); } for(int i = 0; i &amp;lt; ans_list.size(); i++) { pii current = ans_list[i]; if(current.first == a &amp;amp;&amp;amp; current.second == b) { ans_list.erase(ans_list.begin() + i); break; } } cout &amp;lt;&amp;lt; ans_list[0].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ans_list[0].second &amp;lt;&amp;lt; endl; ans_list.erase(ans_list.begin()); }}F - ABCBA문제 내용문자열 S가 주어졌을 때, 문자열 S를 prefix로 하는 팰린드롬을 만들어야 한다.풀이보자마자 manacher 알고리즘이 떠올랐다.manacher 알고리즘은 특정 위치를 중심으로 팰린드롬의 길이를 구할 수 있는 알고리즘이다.만약 이렇게 어떤 위치에서 구한 팰린드롬이 문자열 끝까지 도달할 수 있다면, 문제에서 원하는 문자열 S를 prefix로 하는 팰린드롬을 만들 수 있는 상황일 것이다. 따라서 앞에서부터 순차적으로 확인하다가 해당 경우인경우 바로 출력하게 했다.단, 이때 홀수 길이의 팰린드롬과 짝수 길이의 팰린드롬인지에 따라 약간의 구현 처리가 필요하다.아래 코드는 manacher 알고리즘의 일부 구현 내용을 생략하여 문제에 맞게 활용한 코드이다.vector&amp;lt;int&amp;gt; manacher(string&amp;amp; s){ int n = s.size(), R = -1, p = -1; vector&amp;lt;int&amp;gt; A(n); for(int i=0; i&amp;lt;n; i++){ if(i &amp;lt;= R) A[i] = min(A[2*p-i], R-i); while(i-A[i]-1 &amp;gt;= 0 &amp;amp;&amp;amp; i+A[i]+1 &amp;lt; n &amp;amp;&amp;amp; s[i-A[i]-1] == s[i+A[i]+1]) A[i]++; if(i+A[i] &amp;gt; R) R = i+A[i], p = i; } return A;}string space(string&amp;amp; s){ string t; for(char c: s) t+= c, t+= &#39; &#39;; t.pop_back(); return t;}void solve() { string s, o; cin &amp;gt;&amp;gt; s; o = s; int n = s.length(); s = space(s); vector &amp;lt;int&amp;gt; ret_1 = manacher(s); int k = ret_1.size(); int ans = ret_1.size() - 1; for(int i = 0; i &amp;lt; k; i++) { if (i + ret_1[i] == k - 1) { ans = i; break; } } if(ans % 2 == 0) { int org_idx = ans / 2; for(int i = 0; i &amp;lt;= org_idx; i++) { cout &amp;lt;&amp;lt; o[i]; } for(int i = org_idx - 1; i &amp;gt;= 0; i--) { cout &amp;lt;&amp;lt; o[i]; } } else { int org_idx = ans / 2; for(int i = 0; i &amp;lt;= org_idx; i++) { cout &amp;lt;&amp;lt; o[i]; } for(int i = org_idx; i &amp;gt;= 0; i--) { cout &amp;lt;&amp;lt; o[i]; } }}G - Not Only Tree Game문제 내용E번에서 주어지는 문제 조건과 유사하다.단, 해당 문제에서는 트리가 아닌 그래프가 주어진다.심지어 서로 연결되어 있지 않는 경우도 존재한다.이때 2명의 플레이어가 게임을 진행한다고 했을 때 어떤 플레이어가 이기는지 출력해야 한다.풀이풀이가 전혀 떠오르지 않았다.에디토리얼은 여기 있다.결론그래도 7문제중 6문제를 무난하게 풀이한 contest 였다.오랫동안 굳었던 머리가 다시 풀리는 느낌이라 좋았던 대회지만, 대회 자체의 문제 난이도와 배치는 조금 이상했던 것 같다." }, { "title": "Atcoder Beginner Contest 396 후기", "url": "/posts/abc-396/", "categories": "atcoder", "tags": "atcoder, 문제풀이", "date": "2025-03-09 18:20:00 +0900", "snippet": "개요대회 링크어제 (03/08) 저녁 9시부터 10시 40분까지 진행된 Atcoder Beginner Contest 396 후기입니다.총 7문제 중 5문제를 풀었습니다.A ~ D번까지 문제를 보자마자 바로 풀이하였고, 21분 소요했습니다. 여전히 구현이 느립니다. 더 땡겨야 합니다.E번 문제를 대강 풀이하고 제출했는데, 최적화된 해답을 출력하지 않았고, 이를 해결하는데 시간을 오래 사용했습니다.마지막 제출을 대회 종료 5초전에 했고, 대회가 종료된 후 AC를 확인했습니다.공식 에디토리얼 (해설)풀이 해설은 꼭 문제를 한번 읽고 확인해주세요.A - Triple Four 3번 연속된 숫자가 있는 경우, Yes 아니면 No를 출력한다.문제에 주어지는대로 바로 구현하면 됩니다.B - Card Pile스택에 카드를 넣는 연산과 맨 위의 카드를 확인한 후, 빼는 연산 구현문제에서 주어지는대로 스택을 사용하면 됩니다. 단, 100개의 0을 이미 넣어놓은채 시작하는 전제조건을 확인해야 합니다.C - Buy Balls검정색 공들과 흰색 공들이 숫자가 적혀진 채로 주어진다.각 공을 고르고, 고른 공의 숫자들을 합쳤을 때 최대가 되도록 해야 한다. 단, 고른 검정색 공의 수가 흰색 공의 수보다 크거나 같아야 한다.아래와 같이 그리디하게 최대한 검정, 흰색을 동시에 선택하다가, 흰색공을 선택하지 않아도 되는 경우에는 검정색만 고르도록 했다.def solve(): B = sorted(B, reverse=True) W = sorted(W, reverse=True) s = 0 for i in range(min(n, m)): if B[i] + W[i] &amp;gt; 0 and W[i] &amp;gt; 0: s += B[i] + W[i] elif B[i] &amp;gt; 0: s += B[i] for i in range(min(n, m), n): if B[i] &amp;gt; 0: s += B[i] return sD - Minimum XOR Path그래프가 주어진다. 그래프의 간선에 가중치가 주어진다.다만, 해당 가중치를 더하는 연산이 아닌, XOR 연산을 수행했을 때, 1 ~ N 까지 단순 경로로 도달했을 때 최소 값을 구하라N이 크지 않게 주어졌다. DFS로 모든 단순 경로를 탐색하도록 했다. 아래에 일부 코드를 적어두었다.n = m = 0edges = []mn = []chk = []def dfs(node, label): global n, m, edges, mn, chk if chk[node]: return chk[node] = True mn[node] = min(mn[node], label) for edge in edges[node]: dfs(edge[0], label ^ edge[1]) chk[node] = Falsedef solve(): global n, m, edges, mn, chk dfs(1, 0) print(mn[n])E - Min of Restricted Sum문제가 복잡하게 주어졌지만, 요약하자면 다음과 같다.노드 번호1, 노드번호2, 두 노드 사이의 가중치가 나열된다.각 노드마다의 값을 구해야 한다. 이때 각 노드 사이의 값 끼리 XOR연산을 했을 때 주어지는 가중치와 동일하도록 해야 한다.문제를 보다보니, XOR 연산의 특성을 고민해보다 결국 시작 노드에서 아무 값으로 시작해도 그래프가 정상적으로 주어졌다면 어떻게든 값이 나온다는 사실을 알았다.그래서 무작정 각 노드마다 탐색을 해서, 탐색이 되지 않은 경우 0으로 시작해서 그래프를 탐색하도록 했다.하지만, 이는 틀린 답이었고, 이유를 찾지 못하다가 뒤늦게 문제 상 주어진 조건을 놓쳤음을 알게 되었다.If there are multiple good sequences with the same minimum sum, printing any of them is accepted.그럼 최소를 어떻게 찾아야할까를 계속 고민하다가, 각 그래프 탐색을 하면서 탐색이 된 노드들을 그룹지어놓고, 각 그룹마다 1, 2, 4, 8, 16, … 를 모든 노드값에 XOR 연산을 하면서 최소값이 된 경우 갱신을 하는식으로 구현을 추가했다.해당 구현을 하다가 조금 구현 실수를 하면서 WA를 계속 맞았지만, 대회 종료 직전에 제출한 코드가 AC를 받으면서 종료되었다.결론이번에는 E번 문제를 좀 쉽게 접근하고나서, 더 생각이 떠오르지 않아 망설임이 많았습니다.XOR 연산에 대해서 좀더 잘 알게 된 competition이었던 것 같습니다." }, { "title": "Atcoder Beginner Contest 395 후기", "url": "/posts/abc-395/", "categories": "atcoder", "tags": "atcoder, 문제풀이", "date": "2025-03-02 11:50:00 +0900", "snippet": "개요대회 링크어제 (03/01) 저녁 9시부터 10시 40분까지 진행된 Atcoder Beginner Contest 395 후기입니다.총 7문제 중 5문제를 풀었습니다.A ~ E번까지 문제를 보자마자 해답은 바로 떠올랐지만, 코드를 작성하는 시간이 오래 걸렸습니다. F번, G번 문제를 읽고나서 도저히 바로 해답이 안떠올라서 대회를 그대로 종료했습니다.공식 에디토리얼 (해설)풀이 해설은 꼭 문제를 한번 읽고 확인해주세요.A - Strictly Increasing?N 개의 숫자가 주어집니다.N 개의 숫자들이 엄밀하게 증가하는 수열로 주어졌는지 판단하면 됩니다. 그냥 구현하면 됩니다.B - Make Target자연수 N이 주어집니다.문제 규칙에 맞게 `#`과 `.`을 찍으면 됩니다.수식으로 바로 해결해도 되고, N의 범위가 작기 때문에 반복문으로 돌려도 충분히 해결됩니다.C - Shortest Duplicate SubarrayN 개의 숫자가 주어집니다.주어지는 수열에서 `중복되는 숫자가 있는 부분 수열 중 최소 길이`를 구해야 합니다.언뜻보면 브루트포싱으로 할 수 있겠다 싶지만, 숫자 범위가 그렇지 않습니다.곧바로 각 숫자마다 분류하여 index를 저장했고, 각 index를 훑으면서 최소 격차를 가진 곳을 찾아 반환했습니다.(처음에 문제를 잘못 읽어서 중복된 숫자가 없는 수열로 보았다가 시간 낭비를 했습니다.)D - Pigeon Swap해당 문제에서는 3가지의 연산이 있습니다.1. 비둘기 한 마리가 이동한다.2. 두 둥지에 있는 비둘기들이 서로 다 바꾼다.3. A번 비둘기가 어디있는지 출력한다.저는 이 문제를 보자마자, 그냥 어? 둥지 안에 있는 비둘기를 서로 바꾸는게 아니라 둥지에 가상의 라벨이 붙어있다고 생각하고, 그 라벨을 바꿔 붙였다고 생각하면 되는거 아닌가? 라고 생각을 했습니다.그래서 비둘기마다 위치하는 둥지 위치, 각 둥지(번호를 매겨놓은)마다 붙어 있는 라벨, 각 라벨마다 붙어있는 둥지 원래 번호를 각각 저장했고제 연산마다 적재적소로 활용해서 문제를 풀이했습니다.어찌보면 포인터를 활용했다고 할 수 있겠네요.아래는 코드의 일부 내용입니다def solve(): N, Q = mii() pigeon_place = [i for i in range(0, N)] place_label = [i for i in range(0, N)] place_label_rev = {} for i in place_label: place_label_rev[i] = i for _ in range(Q): commands = mii() if commands[0] == 1: a, b = commands[1:] a -= 1; b -= 1 pigeon_place[a] = place_label_rev[b] elif commands[0] == 2: a, b = commands[1:] a -= 1; b -= 1 A = place_label_rev[a] B = place_label_rev[b] place_label[A], place_label[B] = place_label[B], place_label[A] place_label_rev[a], place_label_rev[b] = B, A else: a = commands[1] a -= 1 print(place_label[pigeon_place[a]] + 1)E - Flip Edge그래프가 주어집니다.이때 1번 노드에서 N번 노드로 이동하면서 최단 거리를 알아내야 합니다.단, 각 간선의 길이는 무조건 1입니다.그리고 모든 간선의 방향을 뒤바꾸는 연산을 하면서 X 비용을 낼 수도 있습니다.저는 문제를 보고, 이건 무조건 다익스트라 알고리즘으로 하면 되겠다 였고, 단 거리를 저장하는데 있어서Distance[어느 방향으로 이 노드에 도달했는가? (0: 정방향, 1: 역방향)][노드 번호]와 같이 거리를 저장하기로 했고각 노드에서 다시 방향을 유지하여 갈때는 원래 비용인 1을 사용하고, 방향을 바꿔서 갈때는 X + 1을 사용하여 가기로 설정했습니다.아래는 코드의 일부 내용입니다.struct Edge { ll node; ll cost; ll direction; Edge(ll node, ll cost, ll direction) : node(node), cost(cost), direction(direction) {} bool operator&amp;lt;(const Edge &amp;amp;to) const { return cost &amp;gt; to.cost; }};ll N, M, X;vector&amp;lt;vector&amp;lt;vector&amp;lt;Edge&amp;gt; &amp;gt; &amp;gt; edges;ll dist[2][220000];ll dijkstra(ll s) { priority_queue&amp;lt;Edge&amp;gt; pq; pq.push(Edge(s, 0ll, 0)); pq.push(Edge(s, X, 1)); dist[0][s] = 0; dist[1][s] = X; // 모든 엣지를 역방향으로 바꾸면서 시작하는 경우 while (!pq.empty()) { Edge cur = pq.top(); pq.pop(); if (cur.cost &amp;gt; dist[cur.direction][cur.node]) continue; // 만약 정방향으로 간다면 for(auto nxt : edges[cur.direction][cur.node]) { if (dist[cur.direction][nxt.node] &amp;gt; cur.cost + nxt.cost) { dist[cur.direction][nxt.node] = cur.cost + nxt.cost; pq.push(Edge(nxt.node, dist[nxt.direction][nxt.node], cur.direction)); } } // 만약 역방향으로 바꿔서 간다면 for(auto nxt : edges[1 - cur.direction][cur.node]) { if (dist[1 - cur.direction][nxt.node] &amp;gt; cur.cost + X + nxt.cost) { dist[1 - cur.direction][nxt.node] = cur.cost + X + nxt.cost; pq.push(Edge(nxt.node, dist[1 - cur.direction][nxt.node], 1 - cur.direction)); } } } return min(dist[0][N], dist[1][N]);}void solve() { for1(0, M) { ll a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; edges[0][a].push_back(Edge(b, 1, 0)); edges[1][b].push_back(Edge(a, 1, 1)); } cout &amp;lt;&amp;lt; dijkstra(1);}F - Smooth Occlusion 풀이 X..G - Minimum Steiner Tree 2 풀이 X..결론무난하게 5문제를 풀이하고나서, F, G번을 트라이할만한 시간이 남은 competition이었습니다.다만, 오랜 기간동안을 손을 놓아서인지 구현 속도가 느리기도 했고 조금이라도 어려운 요소가 섞이니 접근이 잘 안되고 있습니다.백준에서 골드/플레 문제 풀이를 해야할 것 같습니다.." }, { "title": "새로운 시작을 준비하며, 그렙을 떠나 다시 학교로 돌아갑니다", "url": "/posts/grepp-memoir/", "categories": "회고록", "tags": "회고록, 그렙, 프로그래머스", "date": "2025-02-26 13:25:00 +0900", "snippet": "새로운 시작을 준비하며, 그렙을 떠나 다시 학교로 돌아갑니다안녕하세요, 백엔드개발자 김신건, Koa 입니다.저는 2019년부터 함께한 그렙(Grepp)을 떠나, 다시 대학교로 돌아가기로 결심했습니다.오랜 시간 인턴부터 정직원까지 쌓아온 경험과 애정이 깊은 회사지만, 지금은 제 자신을 더 깊이 탐구하기 위해 돌아가야 할 시점이라 느끼게 되었습니다. 이 결정은 분명 쉽지 않았습니다. 이 결정이 또 다른 성장의 기회가 될 거라 믿습니다.그렙과의 지난 여정을 정리하면서, 저의 지난 발자취에 대해서도 공유해보고자 합니다.C 언어 하나로 바뀐 꿈저는 개발자를 꿈꾸던 사람이 아닙니다.저는 어릴 적부터 기계공학자를 꿈꾸었고, 기계나 로봇을 설계하고, 설계한 것이 실제로 움직이는 걸 보면 가슴이 뛰는 아이였습니다. 하지만 “과연 내가 기계를 아주 잘 설계하고, 활용할 수 있는 사람인가?” 하는 근본적인 의문이 늘 따라다녔습니다. 그런 고민을 품고 지내던 중, 고등학교(한민고등학교) 방과 후 수업에서 C 프로그래밍을 처음 접했습니다.처음에는 그저 호기심으로 시작했던 C 언어 공부였지만, 코드업(CodeUp) 사이트의 기초 100제를 풀어나가는 과정이 꽤 재미있었습니다. “나, 이거 꽤 잘하는 것 같은데?” 라는 작은 자신감이 쌓인 후, 300문제, 400문제를 연달아 풀었습니다. 그리고 곧장 정보선생님에게 찾아가 지금 당장 해야하는 공부에 댈해서 질문했습니다. 그렇게 알고리즘과 자료구조에도 본격적으로 입문했습니다. (그렇게 내신 성적은 점점 떨어졌지만요)이때부터 여러 알고리즘 대회에 참가하기 시작했습니다. 다른 대회 참가자들에 비해 늦게 출발한 만큼 화려한 수상 성적을 거두진 못했습니다. 그래도 꾸준히 노력한 덕분에 가끔씩 장려상이나 동상을 받았고, 그 경험들이 저에겐 큰 동기부여가 되었습니다. 그리고 그 많은 대회 속에서 프로그래머스(Programmers) 사이트를 통해 대회가 진행되었는데, 이 플랫폼을 운영하는 기업이 바로 그렙이라는 사실을 훗날 알게 됩니다.소프트웨어 특기자 전형으로 대학에 입학하다고등학교 시절 학업 성적은 점점 떨어졌지만, 그동안 쌓아온 대회 수상 기록, 소논문 등으로 소프트웨어 특기자 전형에 도전했습니다. 6개의 대학에 지원했지만 그 중 5개는 고배를 마셨고, 마지막 한 곳에서 극적으로 합격 통지를 받았습니다. 그렇게 대학교에 입학해, 1학년 1학기를 보내며 여러 수업을 들었고, 방학 시즌에 현장실습을 하면 학점과 인턴 월급을 함께 받을 수 있다는 사실을 알게 되었습니다.당시 여러 회사에 지원했지만, 최종적으로 그렙의 알고리즘 콘텐츠 제작 인턴으로 합격하여 방학을 그렙에서 보내게 되었습니다. 이 시기가 저와 그렙의 인연이 본격적으로 시작된 때입니다.1학년 1학기 방학, 그렙에서 첫 인턴십처음 회사로 출근하여, “내가 지금까지 공부해온 게 실제로 이렇게 쓰이는구나!”라는 사실이 무척 신기했습니다. 특히 제가 대회에서 사용했던 프로그래머스 서비스 내의 알고리즘 콘텐츠/문제들을 제작하는 과정에 기여할 수 있었다는 점이 큰 보람으로 다가왔습니다.그래서 저는 최대한 열심히 업무를 수행했고, 저 스스로의 최대한의 역량을 발휘했습니다. 그리고 그렙에서 인연을 이어가며, 2학년 1학기 방학 때까지 알고리즘 콘텐츠 제작자로 계속 근무할 기회를 얻었습니다.2학년 이후, 웹 개발로 시야를 넓히다1학년에서 2학년 사이 기간 동안 스스로 한계를 느끼기도 했습니다. “내가 잘하는 건 알고리즘 문제 풀이뿐인가?”라는 생각이 들었습니다.1학년의 저는 알고리즘만 아는 코더였던거죠. 그냥 문제 풀이만 할 줄 아는 사람이었습니다. 그것도 깊게 하지 못하는.굉장히 스스로 부끄러웠고, 발전이 되고 있지 않았다는 것을 느꼈습니다. 마침 주변 지인들의 조언으로 웹 개발 동아리에 들어가게 됐고, 그곳에서 처음 웹 프레임워크와 프로젝트 구축 방법을 익혔습니다. 2학년 2학기가 끝나갈 즈음, “알고리즘 관련 말고, 웹 개발로 인턴을 할 수 있는 곳이 없을까?” 고민하던 차에, 그렙에서 개발 인턴으로 근무해볼 생각이 없는지 제안을 받았습니다. 덕분에 그렙과의 인연은 또 다른 국면에 접어들었습니다.정직원으로 그렙에 합류, 그리고 군 복무방학 인턴으로 웹 개발에 본격 뛰어들면서, 제가 실제로 사용하던 프로그래머스 서비스를 직접 개발하게 된다는 점이 참으로 매력적이었습니다. Ruby on Rails를 처음 접했고, Vue.js도 함께 다루면서 프론트엔드와 백엔드 양쪽을 모두 맛볼 수 있었습니다.방학이 끝난 후 선택지가 생겼습니다. “계속 학교를 다닐까, 아니면 휴학 후 정직원으로 일하며 더 빠르게 성장할까?” 고민 끝에 저는 그렙에서 정직원으로 근무하기로 했습니다. 이후 2021년, 2022년에 걸쳐 채용사업부의 개발자로서 프로그래머스 채용 서비스와 비즈니스 서비스를 구축하고 개선하는 업무를 맡았습니다. 점차 백엔드 분야에 더 흥미를 느끼게 되어 서버 쪽을 심도 있게 파고들면서, 개발자로서의 시야를 넓혀갔습니다.그러나 그 시기에 산업기능요원 제도가 바뀌면서, 저처럼 현역 판정인 사람은 산업체 복무가 불가능해졌습니다. 결국 군대를 더 이상 미룰 수 없다고 판단해 갑작스럽게 군대를 가게 되었습니다. 인생 계획이 어그러진 느낌이었지만, 한편으로는 “군대에서 조금이라도 휴식과 함께 생각을 정리할 수 있는 기회가 있겠지?”라는 희망도 있었습니다. (물론 자대 배치 이후의 현실은 그렇게 간단하지 않았지만요. 군 복무 이야기)전역 후, 다시 그렙으로 복직 … 그리고 또 한 번의 고민군 복무를 마치고 2024년 7월, 다시 그렙에 복직했습니다. 이번에는 교육솔루션팀에 합류해 교육 서비스를 개발하는 일을 맡았습니다. 8개월 정도 근무하면서, 안정적인 루틴과 급여 덕분에 편안함을 느꼈지만, 그 편안함 한편에서 “내가 진짜 하고 싶은 건 뭘까?”라는 고민이 점점 커졌습니다.계속해서 새로운 기능을 만드는 데도 점차 흥미를 잃어가고, 동시에 사적인 프로젝트나 지식 탐구에도 예전 같은 열정을 쏟지 못하고 있다는 걸 깨달았습니다. 군대에 가기 전, “나는 성장하고 싶어!”라고 불타올랐던 그 마음이 어딘가 녹슬어버린 느낌이었습니다. 그러다 보니, &quot;알고리즘만 아는 코더&quot; 시절처럼 정체된 제가 부끄러웠습니다. “안정감만 쫓고 있으면, 결국 제자리걸음 아닌가?”라는 생각과 후회감이 들었고, 이번에는 스스로를 다시 새로운 환경에 던져 몰아붙여야겠다는 결심을 하게 되었습니다.그래서 2025년 2월을 기점으로, 저는 그렙을 떠나 다시 대학으로 복학하기로 마음먹었습니다. 학교에서 좀 더 이론적인 공부를 보완하고, 새롭게 떠오르는 기술들에 집중해보고 싶습니다. 그 이후, 또 새로운 곳에 뛰어들어 가보고 싶습니다.모든 선택에는 리스크가 따르지만, 지금이 아니면 안 될 것 같습니다. 물론 이 선택이 나중에 후회로 남을 수도 있습니다. 하지만 지금 이 시점에서 “기회비용을 감수하면서도 성장을 택하겠다”라는 다짐이, 오히려 저에겐 강력한 동력이 될 것 같다는 생각이 듭니다.떠남은 끝이 아니라 또 다른 도약저는 아직도, 계속해서 제 자신을 “부족한 개발자”라고 생각합니다.특별히 잘하는 한 분야가 확고하게 잡혀 있는 것도 아니고, 일에 완전히 몰입하는 것도 잠시 주춤했던 때가 있었습니다. 그럼에도 &quot;스스로를 몰아붙이고, 낯선 환경에서 새로운 경험에 뛰어드는 것&quot; 만큼은 잘한다고 단언할 수 있습니다.이번 결정이 누군가에게는 이해되지 않을 수도 있고, 저조차 훗날 후회할지 모릅니다. 하지만 그 후회조차도 분명 저를 더 나은 길로 이끄는 &quot;새로운 동기부여&quot;가 될 것이라 믿습니다.그렙에서 함께했던 동료들, 그리고 프로그래머스를 통해 만났던 많은 분들께 감사 인사를 전합니다. &quot;새로운 도전에 뛰어들려는 지금 이 순간&quot;이 훗날 제가 더 큰 성장을 할 시작점이 되리라 믿습니다.감사합니다." }, { "title": "Atcoder Beginner Contest 394 후기", "url": "/posts/abc-394/", "categories": "atcoder", "tags": "atcoder, 문제풀이", "date": "2025-02-23 14:00:00 +0900", "snippet": "개요대회 링크어제 (2/22) 저녁 9시부터 10시 40분까지 진행된 Atcoder Beginner Contest 394 후기입니다.총 7문제 중 5문제를 풀었습니다.A ~ D까지 4문제는 대회 시작후 13분 안에 풀이했지만 E번 정확한 풀이를 생각해내는데 60분을 썼고, F번 문제를 읽고 끝났습니다.공식 에디토리얼 (해설)풀이A - 22222단순히 주어지는 숫자 문자열에서 2의 개수만큼 다시 2를 출력하는 문제입니다.빠르게 구현하면 됩니다.B - cat주어지는 문자열을 문자열의 길이를 기준으로 정렬 후 차례대로 붙여 출력하는 문제입니다.빠르게 구현하면 됩니다.C - Debug주어지는 문자열에서 WA 라는 문자열을 AC 라는 문자열로 계속해서 대체할 때, 최종 문자열을 구하는 문제입니다.예를 들어, WWA 라는 문자열이 있으면 WWA → WAC → ACC 로 변합니다.저는 단순히 처음에는 스택을 활용할까 생각했지만, 문자가 변하는 양상을 보니 W*X개+A*1개 의 형태를 갖춰야만 바뀐다는 걸 캐치하고, W의 개수를 세다가 A 문자가 등장하면 대체하는 식으로 코드를 구성했습니다.D - Colorful Bracket Sequence전형적인 안정적인 괄호 문자열 문제입니다. 다만, 괄호의 종류를 (), &amp;lt;&amp;gt;, [] 로 해두었습니다.따라서, 관련 처리를 하면서 스택으로 해결하면 됩니다.E - Palindromic Shortest Path그래프가 주어집니다. 단, 정점이 아닌 “간선”마다 문자가 기록되어 있는 그래프입니다.이때 모든 정점 사이의 페어마다, 간선의 문자열을 나열해서 팰린드롬이 되도록 하는 경로의 최소 길이를 구해야 합니다.처음에 저는 BFS로 정점마다 출발하여 팰린드롬인지 파악하는 완전탐색으로도 1억 내외로 연산 수가 떨어지면 시간안에 들지 않을까라는 생각으로 트라이했습니다. 하지만 TLE가 나왔고, 다른 방법을 생각해야 했습니다.이때 굳이 간선의 정보가 주어지고 있는데, 정점 기준으로 탐색할 필요가 있을까 생각이 들었습니다.그래서 모든 간선은 일단 문자가 1개로 구성된 팰린드롬이고, 양 옆에 같은 문자를 이어 붙이면 팰린드롬이 되지 않을까 라는 생각으로 알고리즘을 구성했습니다. 먼저 정방향 간선 정보와 역방향 간선 정보를 저장한다. 모든 간선을 큐에 넣는다. (해당 간선은 길이가 1인 팰린드롬이기 때문에, { 시작점, 끝점, 길이=1 }) 와 같이 넣는다. 아래에서 설명 추가 과정 필요 큐의 맨 앞에 있는 간선에서 정방향 간선 정보와 역방향 간선 정보를 참조해, 앞 뒤로 같은 문자을 붙일 수 있느지, 붙일 수 있다면 그것이 현재 최소 길이인지 확인해서 갱신 후 큐에 다시 넣는다. 갱신된 모든 길이를 출력한다.이 방법의 이점은 일단 간선의 정보만 다룬다는 것이고, 만들어진 문자열들이 팰린드롬인지를 체크할 필요가 없다는 것입니다.그리고 이 방식은 홀수 길이인 경우만 알아낼 수 있는데 따라서 3번 과정에서 모든 i에 대해 i → i 로 가는 가상의 경로에 현재까지의 팰린드롬 길이가 0이다를 집어넣어놓으면 됩니다. { 출발점=i, 끝점=i, 길이=0} 과 같이 말입니다.F - Alkane그래프 정보가 주어집니다.이때 아래 조건을 만족하는 부분 그래프의 최대 크기를 구합니다. 해당 그래프는 무향 그래프다. 모든 정점의 차수는 1 또는 4이다. (해당 정점에 이어지는 간선 수)딱히 떠오르는 해답이 없었습니다…G - Dense Buildings문제조차 읽지 못했습니다.결론7문제 중 5문제를 풀이하면서 점차 예전의 실력을 되찾아가는 느낌이 들었습니다. 언젠가 모든 문제를 막힘없이 자연스럽게 다 푸는 실력까지 도달하고 싶습니다." }, { "title": "2022년 11월부터 시작된 1년 6개월 회고록", "url": "/posts/army-memoir/", "categories": "회고록", "tags": "회고록, 군대", "date": "2024-05-28 15:00:00 +0900", "snippet": " 길면서 짧았던 군 생활을 마무리하며, 회고록을 작성한다.서론2022년 11월 28일, 논산 훈련소로 입대했습니다.같이 오신 부모님과 되게 쿨한 작별 인사를 하고, 터벅 터벅 들어갔습니다. 이전에는 입소식도 했다고 하지만, 저는 코로나 막바지라 그런 행사 없이 바로 입소 관련 절차를 시작했습니다.훈련소 내에서도 여러 일이 있었지만.. 시간이 바로 흘러 어느덧 수료식이었습니다. 수료식이 끝나고 부모님과 외출/면회를 하면서 저의 자대 배치 결과를 확인했습니다.특전사령부.????????? 저는 굉장히 당황스러웠고, 왜? 내가 어째서? 이게 맞아?일단 특전사령부는 어디있지 하고 찾아보았고, 경기도 이천에 있다는 것을 확인했습니다. 와, 그래도 집 앞에 있는 부대로 가는구나 싶어서 신났습니다. (본가가 이천입니다)그렇게 외출에서 복귀하고 자대 배치일을 기다려서, 그날이 왔습니다.하지만 뭔가 이상했습니다. 이천으로 가는 길이라고 하기엔 너무 멀었고, 담당 간부님은 제가 전남 담양으로 간다고 말씀하셨습니다. 거기는 어디지..? 하고 물어보니 11공수특전여단이었고, 특전사령부의 예하 여단으로 가는 것이었습니다. 아.. 예하 부대는 표기가 안되는 거였구나 싶었고, 그렇게 전남 담양에서의 군 생활이 시작되었습니다.자대 배치 후, 군 생활이 새로 시작되었다 할만큼 굉장히 많은 업무와 생활 룰(?)을 배웠고, 숙지했습니다.그 이후, 여러 훈련도 하고, 업무/공부/운동을 반복하다 보니 1년 반이 흘렀습니다. (자세한 내용은 스킵. 알고 싶으면 술 사주면서…ㅎㅎ)이제 한번 어떤 걸 공부했었는지 정리해보려 합니다. (군 관련 내용은 일부러 안 적었습니다.)군대에서 공부하기자격증을 땄다.네트워크관리사 2급 자격증을 군생활 막바지에 땄습니다.사실 필기 시험은 진작에 통과했었습니다. 나중에 따야지..따야지 하다가 막바지에 진짜 이제는 해야한다는 생각을 가지고 나중에서야 땄습니다..그리고 전역 이틀 전에 SQLD 시험을 응시했고, 아마.. 합격이지 않을까 생각합니다.백준 문제라도 풀자.입대 전(2451문제) → 24.05.01(4034문제)로 약 1500문제 이상을 풀었습니다. 그리고 군생활 도중에 다이아5에서 다이아4로도 승급했습니다.뭐.. 최대한 많은 문제와 할 수 있는 공부는 다 해보자라는 생각으로 계속 했던 것 같습니다. 그 덕분에 시간도 금방 간 것 같습니다.강의를 듣자. code.plus 사이트(스타트링크)에서 제공하는 알고리즘 고급으로 가는 연결고리 강의를 들었습니다. 인프런 - 외워서 끝내는 네트워크 핵심 이론 - 기초, 외워서 끝내는 네트워크 핵심 이론 - 응용 강의를 수강했습니다. 네트워크 관리사 자격증을 따면서 더 좋은 지식을 얻을 수 있을까 싶어 강의를 들었습니다. 상당히 좋은 강의였고 추천합니다. 인프런 - 외워서 끝내는 SSL과 최소한의 암호기술 강의를 수강했습니다. 위 네트워크 강의와 이어지는 부분이 많았고, 아직도 다시 찾아보면서 내용을 흡수하고 있습니다. 생활 코딩 - 정규표현식, Web2 : Oauth 2.0 강의를 수강했습니다. 이전부터 조금씩 내가 제대로 알고 있는 게 맞나 싶었던 부분을 긁어주었던 강의였습니다. 전역 후 다시 TIL 글로 정리해보려고 합니다. 인프런 - [그림으로 이해하는] 동기 비동기의 개념에 대한 가장 직관적인 이해라는 강의를 수강했습니다. 사실 거의 아는 내용이 나왔고, 조금 아쉬웠습니다. 차라리 이 강의를 몇 년 전에 비동기에 대한 이해가 없었을 때 봤다면 더 좋았겠다 싶습니다. 인프런 - SVG 마스터 강의를 수강했습니다. 뭔가 유익했지만 군대라는 현실에 실습을 거의 못해봤습니다. 조금 아쉽기에 이걸 활용한 사이드 프로젝트를 진행할 수 있을까 고민해봅니다.앞으로는 뭘 하지?남은 2024년 동안에는 아래 목표를 하나씩 차근차근 해보려 합니다.일간 목표 아침 또는 저녁마다 운동을 한다. (안 되면 산책이라도) 매일 백준 문제 풀기 (적어도 1문제)월간 목표 적어도 2권의 책을 읽는다. (종류 상관 X) 매주 일요일 혹은 매달 마지막에 무엇을 했는지 간단하게 정리하자. TIL Repo에 꾸준히 기록물을 남긴다.연간 목표 회사를 재밌게 다닌다. 연간 백준 500 AC를 도전한다. 자격증 / 운전 면허증 등의 자격증을 꾸준히 딴다. Codeforces / Atcoder Contest에 주기적으로 참여한다. (Blue를 계속 유지할 수 있는 실력이 될 수 있도록) Kaggle을 시작한다. 간단한 사이드 프로젝트를 적어도 2개 진행한다. Spring과 K8s를 공부한다. 재미있는 자취 생활을 한다.아무튼드디어 끝났습니다.제가 거창하게 나라를 지켰다고는 못하겠습니다.저는 누군가가 계속 이어서 지켜오던 한 자리를 지켰고, 자리를 지키는 것 만큼은 최선을 다했다 생각합니다.저는 앞으로 좀 더 다양한 경험을 사회에서 하면서 저의 길을 다시 걸어 가보겠습니다.지금까지, 그리고 앞으로 나라와 각자의 자리를 지켜주시는 군인 여러분 감사합니다.단결." }, { "title": "[BOJ] 16496 큰 수 만들기", "url": "/posts/boj-19496/", "categories": "BOJ", "tags": "BOJ, PS, Sorting", "date": "2023-09-20 23:03:00 +0900", "snippet": "문제 요약 및 풀이16496번: 큰 수 만들기야간 당직을 서면서 직접 숫자를 만들어 나열해가다가, 아이디어가 떠올랐다.임의의 어떤 수 A와 B가 있을 때, 두 수를 합친 AB와 BA가 있다면,그 두 수중 큰 숫자를 선택하는 상황이다.그럼 점차 합쳐지는 과정에서도 똑같은 규칙이 적용되는 것이니, 정렬을 해당 기준으로 하고나중에 합치면 되지 않을까?풀이시에 주의하기… ull 타입 사용하기, 오버플로우 주의 0000…000 은 0 이다. 문제조건을 잘 읽자.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;#define for1(s, e) for(int i = s; i &amp;lt; e; i++)typedef unsigned long long ull;ull ar[1100];ull zero(ull a) { ull ret = 1; if(a == 0) return 10; while(a &amp;gt; 0) { ret *= 10; a /= 10; } return ret;}bool compare(ull a, ull b) { ull x = a * zero(b) + b; ull x2 = b * zero(a) + a; if(x &amp;lt;= x2) return false; return true;}void solve() { int N; cin &amp;gt;&amp;gt; N; for1(0, N) { cin &amp;gt;&amp;gt; ar[i]; } sort(ar, ar+N, compare); if(ar[0] == 0) { cout &amp;lt;&amp;lt; 0; return; } for1(0, N) { cout &amp;lt;&amp;lt; ar[i]; }}int main() { ios::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL); int tc = 1; // cin &amp;gt;&amp;gt; tc; while(tc--) solve();}" }, { "title": "[Algorithm] 일단 나열해본다", "url": "/posts/algorithm-0001/", "categories": "algorithm", "tags": "알고리즘", "date": "2023-09-14 22:44:00 +0900", "snippet": "이 글은 일단 나열하는 글입니다.이 글은 일단 알고리즘/자료구조 등 뭔가 끄적일만한 태그 / 주제를 쭉 나열하겠습니다.이후, 관련해서 글을 정리하면서 개선해보겠습니다…(언젠간…?)기본 기본 문법 및 구현 시간복잡도자료 구조 해쉬 그래프 트리 힙 덱(deque, double-ended queue) 스택 트라이 문자열 연결리스트기초 알고리즘 / 구현 방식 정렬 알고리즘 재귀 함수 완전 탐색 이분 탐색 Simulation 탐욕법(Greedy)수학 벡터 행렬 FFT 유클리드, 확장 유클리드 Miller-Rabin 소수 판별 알고리즘 Pollard-Rho 소인수분해 중국인의 나머지 정리기하 알고리즘 CCW (이건 수학일까?) Convex Hull Trick Half Plane Intersection 불도저 트릭 Voronoi Diagram문자열 알고리즘 KMP 라빈카프 정규식 Manacher Algorithm미분류 이진 검색 트리 DFS BFS Flood Fill Meet in the Middle 위상 정렬 최소 신장 트리 (MST) DP (Dynamic Programming) Bit DP 다익스트라 알고리즘 우선순위큐 DP 최적화 dynamic MST Berlekamp-Massey Segment Tree Segment Tree With Lazy propagation Dynamic Segment Tree Merge Sort Tree Sliding Window Treap Backtracking 이분 매칭 Maximum Flow Minimum Cost Maximum Flow Seg Tree Beats Slope Trick LIS LCS Floyd Warshall Parallel Binary Search Sqrt decomposition Mo’s Algorithm 사수아탕 DP 투포인터 0-1 BFS Stable Marriage Problem / Stable Matching 트리 순회 SPFA Bellman Ford Dinic Hopcroft Karp LCA Sparse Table Strong Connected Component (SCC)" }, { "title": "[끄적이기] 09/13 BOJ 2900", "url": "/posts/just-0004/", "categories": "just", "tags": "끄적이기", "date": "2023-09-13 22:58:00 +0900", "snippet": "BOJ 2900백준에서 2900 문제 풀이를 달성했다.최근에 백준 문제 풀이 관련해서 이런 저런 생각이 많다.브론즈/실버 문제를 더 이상 푸는게 의미있는걸까?근데, 또 랭작은 계속 해왔었고…그렇다고 플레티넘, 다이아 급의 문제를 더 찾아가며 풀기에는 군대 안에서 한계가 있는 것 같다.이 취미 활동은 도대체 어디까지 언제까지 해야하는 것일까.. :thinking:" }, { "title": "[BOJ] 16940 BFS 스페셜 저지", "url": "/posts/boj-16940/", "categories": "BOJ", "tags": "BOJ, PS, DP", "date": "2023-09-10 13:00:00 +0900", "snippet": "문제 요약 및 풀이16940번: BFS 스페셜 저지트리가 주어지고, 노드들을 탐색한 순서가 주어진다.이때, 탐색한 순서가 BFS 탐색으로 가능한 순서가 맞는지 검증하면 된다.처음에는 정말 단순하게 접근했다.그냥 BFS 탐색을 한번 돌면서, level graph를 만들고, level graph 상에서의 level이 비내림차순으로 배치되었는가만 봤다.하지만, 역시나 바로 WA를 받았다. (생각을 좀 하고 풀라고…)문제가 뭘까 생각중에 아래 예제를 질문 게시판에서 봤다.이 경우에는 12354 또는 13245만 가능한데, 2 또는 3을 방문하는 순서에 따라 4 와 5의 방문순서가 결정되기 때문이다.따라서, 12345와 같은 방문 순서가 불가능해진다.그렇기 때문에 위에서 생각한 level graph로 판단하는 건 불가능하다.그래서 결국 주어지는 순서대로 BFS 방문을 직접 해보는데, 다음노드로 넘어갈 때의 순서를 주어진 순서를 참고하여 탐색해보는 방법을 사용했다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i &amp;lt; n; i++)#define for1j(s,n) for(int j = s; j &amp;lt; n; j++)using namespace std;typedef pair &amp;lt;int, int&amp;gt; pii;int N;vector&amp;lt;int&amp;gt; edges[110000];int order[110000];bool chk[110000];int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; N; for1(0, N - 1) { int a, b; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; edges[a].push_back(b); edges[b].push_back(a); } for1(0, N) { int a; cin &amp;gt;&amp;gt; a; order[a] = i; } queue&amp;lt;int&amp;gt; Q; Q.push(1); int crt = 0; while(!Q.empty()) { int f = Q.front(); Q.pop(); if(crt != order[f]) { cout &amp;lt;&amp;lt; 0; return 0; } chk[f] = true; crt++; vector &amp;lt;pii&amp;gt; v; for(int nxt : edges[f]) { if(chk[nxt]) continue; v.push_back({ order[nxt], nxt }); } sort(v.begin(), v.end()); for(auto nxt : v) { Q.push(nxt.second); } } cout &amp;lt;&amp;lt; 1;}" }, { "title": "[끄적이기] 06/17 뭘 했는지? 뭘 하고 있는지? 뭘 할지?", "url": "/posts/just-0003/", "categories": "just", "tags": "끄적이기, 군대에서 공부하기", "date": "2023-06-17 18:20:00 +0900", "snippet": "최근 몸 상태가 그리 좋진 않았다. 휴가를 너무 안 나가면서 정신없어서 그런 것 같기도 하다.이번달 말에 나갈 휴가가 더욱더 기다려지고 있다.뭘 했는지? 코어 자바스크립트 서적을 읽음. 생각보다 자바스크립트를 대충 대충 써먹기 위해서만 알고있었다고 느꼈다. 클로저나 프로토타입에 대해서는 조금 더 익힐 필요가 있다. 인프런 / 인터랙티브 웹 개발 제대로 시작하기 강의를 섹션 6까지 들었다.뭘 하고 있는지? 파이썬 클린코드 2nd Edition (마리아노 아나야 저) 아직도 읽는 중이다. 시간날 때마다 읽으려 하지만, 다른 책들이 먼저 눈에 들어온다.. 핸즈온 머신러닝(오렐리앙 게론 저) 6/17 주말 외출 중에 구매해서, 100여쪽 가량을 먼저 읽어봤다. 아직 이론 부분이라 막막하지는 않지만, 나중에 캐글까지 해보려 하기에 도전중이다. 뭘 할지? 강의 / 책을 꾸준히 공부하기 길지 않고, 짧은 텀으로 빠르게 끝낼만한 토이 프로젝트들을 생각하자." }, { "title": "[끄적이기] 05/31 뭘 했는지? 뭘 하고 있는지? 뭘 할지?", "url": "/posts/just-0002/", "categories": "just", "tags": "끄적이기, 군대에서 공부하기", "date": "2023-05-31 19:05:00 +0900", "snippet": "뭘 했는지? 완전 완료된 게 없다. 조금씩 목표를 쪼개서 해야할 것 같다.뭘 하고 있는지? 인프런 / 인터랙티브 웹 개발 제대로 시작하기 강의 섹션 1. CSS 변환과 애니메이션 완료 원래 알고 있던 내용이라 무난하게 들었다. 파이썬 클린코드 2nd Edition (마리아노 아나야 저) 계속 안 읽고 있다. 그로스 해킹(Growth Hacking):스타트업을 위한 실용주의 마케팅 시간 날때마다 펴서 읽어보려고 시작했지만.. 얼마 못 읽었다. 뭘 할지? 위의 책들 마저 읽기 이후 자격증 공부 어떤 것 해야할지 찾아보기" }, { "title": "[끄적이기] 05/29 뭘 했는지? 뭘 하고 있는지? 뭘 할지?", "url": "/posts/just-0001/", "categories": "just", "tags": "끄적이기, 군대에서 공부하기", "date": "2023-05-29 15:11:00 +0900", "snippet": "왜 이 글을 쓰고 있는가?군대에서 공부는 해야겠다고 마음먹었지만, 계속 뒤로 미루기만 하고맨날 유튜브만 보는 내가 너무 한심해서 글이라도 계속 쓰면서기록이라도 남기려고 한다.뭘 했는지? 네트워크 관리사 2급 필기 시험 합격 원래도 약했던 네트워크 이론을 조금 파볼 수 있는 기회가 되었다. code.plus 강의 듣기 알고리즘 고급으로 가는 연결고리 1/2 알고리즘 고급으로 가는 연결고리 2/2 쭉 강의를 들으면서 기존에 DP나 세그트리에 대해서 단편적으로 생각했었다는 것을 깨달음. 각 강의에서 나온 문제를 다 풀어야 하는데, 맨날 또 미루고 있다. 백준 다이아4 달성뭘 하고 있는지? 파이썬 클린코드 2nd Edition (마리아노 아나야 저) 주말 외출 때, 영풍문고를 갔다가 흥미를 느껴 산 책(이라고 하기엔 책을 한덩이 사고 옴.) 아직 88/427쪽 정도밖에 안 읽었음. 뭘 할지? 파이썬 클린코드 2nd Edition 책 마저 읽기 인프런 / 인터랙티브 웹 개발 제대로 시작하기 강의 듣기" }, { "title": "[BOJ] 2618 경찰차", "url": "/posts/boj-2618/", "categories": "BOJ", "tags": "BOJ, PS, DP", "date": "2023-05-27 18:23:00 +0900", "snippet": "문제 요약 및 풀이2618번: 경찰차1. 두 경찰차가 모든 사건을 처리하러 이동해야 한다.2. 모든 사건을 주어지는 순서대로 처리해야 한다.3. 두 경찰차는 처음에 각각 (1, 1), (N, N)에 위치한다.이때, 두 경찰차가 이동하는 최소 거리를 구해야 한다.일단 먼저 모든 경우를 탐색한다고 생각해보고 접근해보자.사건의 개수는 C개 (&amp;lt;= 1000)이다.그럼 사건을 두 경찰차가 각각 배정받게 만들고, 이를 계산을 순서대로 해본다고 하자.시간복잡도는 2^C 가 되며, 문제의 최대 범위로 입력이 들어올 경우 최대 2^1000 만큼 연산해야 한다.무조건 시간초과가 뜰 것이다.생각을 간단히 해보자.만약에 첫번째 경찰차가 2번째 사건까지 처리하고,두번째 경찰차가 4번째 사건까지 어찌저찌 처리했다 해보자.그럼 다음으로 처리해야 하는 사건은 어떤 사건인가?당연하게도 5번째 사건을 처리해야 한다.왜? 바로 순서대로 사건을 처리해야 한다는 조건때문이다.이 점을 이용해서 DP 식에 넣고 이용해보자.i는 첫번째 경찰차의 마지막 위치라하고j는 두번째 경찰차의 마지막 위치라 할 때DP[i][j] = 두 경찰차가 이동한 최소 거리라 하자.단, i와 j는 같을 수 없다. (i와 j가 같다는 것은 두 경찰차가 같은 사건을 처리했다는 의미이므로 배제해야 한다.)DP[i][j] 를 이용해서 알아낼 수 있는 값은 어떤 것이 있을까?첫번째 경찰차 또는 두번째 경찰차가 이동하는 경우일테니 아래와 같을 것이다.// 첫번째 경찰차가 이동한 경우int nxt = max(i, j) + 1;DP[nxt][j]] = DP[i][j] + dis(points[i], points[nxt]);// 두번쨰 경찰차가 이동한 경우int nxt = max(i, j) + 1;DP[i][nxt]] = DP[i][j] + dis(points[j], points[nxt]);풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i &amp;lt; n; i++)#define for1j(s,n) for(int j = s; j &amp;lt; n; j++)#define foreach(k) for(auto i : k)#define foreachj(k) for(auto j : k)#define pb(a) push_back(a)#define sz(a) a.size()#define INF 100000000using namespace std;typedef unsigned long long ull;typedef long long ll;typedef vector &amp;lt;int&amp;gt; iv1;typedef vector &amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; iv2;typedef vector &amp;lt;ll&amp;gt; llv1;typedef unsigned int uint;typedef vector &amp;lt;ull&amp;gt; ullv1;typedef vector &amp;lt;vector &amp;lt;ull&amp;gt; &amp;gt; ullv2;struct Point { int y, x;};struct st { Point p; Point rev; int cost;};struct cmp{ bool operator()(st a, st b){ return a.cost &amp;gt; b.cost; }}; int N;int C;Point points[1100];int D[1100][1100];Point back[1100][1100];int dis(Point a, Point b) { return abs(a.x - b.x) + abs(a.y - b.y);}int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; C; for(int i = 0; i &amp;lt;= C + 1; i++) for(int j = 0; j &amp;lt;= C + 1; j++) D[i][j] = INF; points[0] = {1, 1}; points[1] = {N, N}; for(int i = 2; i &amp;lt;= C + 1; i++) cin &amp;gt;&amp;gt; points[i].y &amp;gt;&amp;gt; points[i].x; priority_queue &amp;lt;st, vector&amp;lt;st&amp;gt;, cmp&amp;gt; q; q.push({ {0, 1}, {0, 0}, 0}); while(!q.empty()) { st here = q.top(); q.pop(); int y = here.p.y; int x = here.p.x; if(D[y][x] &amp;lt;= here.cost) continue; D[y][x] = here.cost; back[y][x] = here.rev; int nxt = max(y, x) + 1; if(nxt &amp;gt; C + 1) continue; q.push({ {y, nxt}, here.p, here.cost + dis(points[x], points[nxt])}); q.push({ {nxt, x}, here.p, here.cost + dis(points[y], points[nxt])}); } stack &amp;lt;Point&amp;gt; stk; int ans = INF; Point s; for(int i = 0; i &amp;lt;= C + 1; i++) { if(D[i][C + 1] &amp;lt; ans) { ans = D[i][C + 1]; s = {i, C + 1}; } if(D[C+ 1][i] &amp;lt; ans) { ans = D[C + 1][i]; s = {C + 1, i}; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\\n&quot;; while(s.x != 0 || s.y != 0) { stk.push(s); s = back[s.y][s.x]; } while(!stk.empty()) { Point here = stk.top(); stk.pop(); if(stk.empty()) continue; Point there = stk.top(); if(here.x != there.x) cout &amp;lt;&amp;lt; 2; else cout &amp;lt;&amp;lt; 1; cout &amp;lt;&amp;lt; &quot;\\n&quot;; }}" }, { "title": "2년차 주니어 개발자 / 휴학생 / 예비 군인의 미리 쓰는 2022년 회고록", "url": "/posts/goodbye-2022/", "categories": "회고록", "tags": "회고록, 주니어 개발자", "date": "2022-10-30 16:05:00 +0900", "snippet": " 2년차 주니어 개발자, 휴학생, 예비 군인 등 많은 수식어가 생긴 올해의 회고록은 일찍 써보려 한다.서론이 회고록은 왜 일찍 쓰여지는 걸까?작년 회고록 에서도 언급되었지만, 군대를 가야 합니다.최대한 올해가 가기전에 입대를 하기 위해, 두 번이나 SW 개발병에 지원을 했었지만, 첫번째는 면접에서 탈락, 두번째는 서류에서 탈락했습니다.아무래도 SW 개발병 점수에 포함되는 학력 점수가 영향을 많이 줬지 않았을까 생각하고 있습니다… (휴학을 너무 빨리 했습니다 ㅠ)아무튼, SW 개발병으로 개발을 하면서 군대 생활을 하기엔 힘들겠다 판단했고, 기술행정병으로 지원했고 정보체계운용/정비 특기로 11월 28일에 입대합니다.11월 언저리 넘어서야 올해 회고록 좀 써볼까 해왔었지만, 올해는 좀 서둘러봅니다.올해는 큰 변화가 있었을까?솔직히 큰 변화는 없던 한해 같습니다.매일 아침 일어나 리모트 근무를 시작하고, 업무 시간이 끝나면 저녁을 먹고 독서 / 알고리즘 공부 / 유튜브 또는 넷플릭스 보기만 반복을 했던 것 같습니다.어쩌면 2년동안 반복되는 생활에 큰 변화를 주면서, 언젠가는 해야 하는 의무를 다하기 위해 올해가 가기전에 입대를 하기로 한 것 같습니다.올해는 뭘하며 지낸걸까?회사 업무는 끝이 없었다.JIRA 사이트에서 올해 내가 맡았던 이슈들 개수를 뽑았을 때 총 290개(2022.10.12 기준)가 나왔습니다…처음에 뽑고나서 이렇게까지 많이 했었나? 라는 생각이 들었지만, 한번씩 제목들을 살펴봤더니 모두 기억에 남아있는 내용들이었습니다.그 중에 기억에 남는 업무들을 간접적으로 나열해보고자 합니다.1. 어쩌다보니 실험실이 된 프로젝트다른 서비스에서 제공하는 API를 활용해야 하는 업무가 있었습니다. 근데 해당 서비스에서 제공하는 API는.. 여러 복잡한 과정들을 거쳐서 값을 복호화 / 암호화해야 했습니다. 우리 부서만 사용하는게 아니었습니다.그래서 결국 해당 API를 한번 걸러서 간편하게 사용할 수 있는 서버리스 프로젝트를 만들기로 했습니다.그렇게 해당 프로젝트를 활용할 부서들에서 사람들이 모여서 개발을 시작했습니다.해당 프로젝트를 진행하기 위해 여러 기술 / 인프라들이 합쳐지기 시작했는데,,,Python, Flask, Docker(docker-compose), DynamoDB, AWS ECR, AWS Lambda, AWS API Gateway, Terraform 등Python과 Flask개발 자체는 Python과 Flask 프레임워크를 사용했습니다. (개발을 같이 하는 동료들의 주 언어가 대부분 Python 이었고, 간편하고 빠르게 개발할 수 있을 거라 생각했습니다.)Terraform그리고 해당 프로젝트의 인프라를 구성할 때, 가장 먼저 고려한 건 Terraform 이었습니다.Terraform을 이용해 기본적인 VPC 부터 Lambda까지 모든 인프라를 구성하기로 했습니다. 사내에서 여러 프로젝트 인프라들이 Terraform으로 구성되고 있던 추세였고, 사용성이 나쁘지 않다고 생각되어서 도입을 하기로 했습니다.DockerAWS Lambda에 .zip 파일을 이용하여 배포하는 방식이 아니라,Docker Container Image를 빌드하고, 해당 Image를 AWS ECR에 올린 후에, AWS Lambda에서 해당 이미지를 가져다가 구동하는 방식으로 배포하려 했기 때문에 Docker를 도입했습니다.물론, 개발 과정 중 서버를 띄우는 등에서의 편리함이나 DynamoDB를 쉽게 로컬에서 테스트하기 위함도 있었습니다.배포 과정 중에 API Gateway에 접근이 안되거나, 리소스 제한 정책, 보안 그룹 등의 설정들이 제대로 파악되지 않아 이슈가 있었습니다만..어찌저찌 해결되어 결국 위 기술들이 모두 혼합되어 지금까지 잘 작동하고 있습니다. (자세히 이야기를 남기기엔 애매하네요.. 우리 회사에도 기술블로그 글을 쓴다면.. 할만한 이야기겠네요 ㅎㅎ)그리고 추가적인 유지보수 작업들도 잘 이어지고 있는 상황입니다.2. Jsonb 컬럼 치워!DB 테이블 중, 한 테이블에 Jsonb 라는 타입의 컬럼들이 많이 있는 상황이었습니다.말 그대로 컬럼에 Json 문자열이 들어가있기 때문에, 빠르게 안에 있는 정보를 파악하거나, DB Query로 통계를 뽑는 등의 작업이 쉽지 않았습니다. (Json 문자열 안에는 배열도 있었고, 2번, 3번이 중첩된 구조도 있었으며, FK 형식의 id값도 들어가있었습니다…)Json 문자열 구조가 들어가있다보니, 임의적으로 데이터를 마이그레이션 하기도 쉽지 않았죠.언젠가 뜯어고치고 만다! 라는 마음을 가지고 있었는데, 올해가 가기전에 편안하게 처리를 하게 되었습니다.하는 방법은 의외로 간단했지만 험난했습니다. 새로운 테이블 / 모델 생성 기존의 Jsonb 컬럼에 있는 데이터를 옮기는 마이그레이션 잡 생성 기존 Jsonb 데이터로 사용하고 있던 “모든 부분”을 찾아내어 새로운 모델로 대체하기1번은 그럭저럭 기존 Jsonb 내에있는 내용을 그대로 가져다 쓰는 거기에 큰 이슈는 없었습니다.2번은 계속해서 써오고 있는 최적화 방법으로 쉽게 해결했습니다. 단순히 Insert 또는 Update하는 것을 쪼개서 실행하는 것이죠.. 마이그레이션하는 대상이몇 십만개씩이었기 때문에, 한번에 Insert / Update를 하게되어 마이그레이션을 하다가 서버가 힘들어하는 상황을 막으려 했습니다.# 임의적으로 모델이나 테이블명을 바꾸었습니다module Migrations class MigrateHelloModelJob &amp;lt; ApplicationJob queue_as :default def perform max_id = HelloModel.maximum(:id) 0.upto(max_id / 10_000 + 1).each do |i| ActiveRecord::Base.connection.execute &amp;lt;&amp;lt;-SQL.squish INSERT INTO future_hello_models (blah) SELECT blah FROM hello_models WHERE hello_models.id &amp;gt; #{i * 10_000} AND hello_models.id &amp;lt;= #{(i + 1) * 10_000} SQL end end endend3번은 코드 검색을 더불어서, 지금까지 해당 모델들이 쓰였던 부분들을 다 순회하면서 찾아내어 TODO 코멘트를 붙여놓은 뒤, 다 정리했습니다.그리고나서 워낙에 큰 마이그레이션이다 보니, 사용자들이 해당 서비스를 비교적 사용하지 않는 새벽에 점검 화면을 띄우고 배포를 진행하였습니다.해커톤, 공모전 그리고 토이 프로젝트들올해도 마찬가지로 사이드 프로젝트들을 했고, Github 링크와 간단한 설명을 정리하여 남겨보겠습니다.TTL Velog / 티스토리 / 깃헙 블로그 등에 흩어져 있는 TIL을 모두 모아보는 서비스해당 프로젝트를 하면서, 처음으로 celery를 도입하여 사용해보았습니다.하지만 celery 큐를 통해 주기적으로 사용자의 TIL 글들을 동기화하는 job을 돌리는 과정에서,서버 리소스의 최적화가 되지 않아 주기적으로 웹서버가 죽는 이슈가 있었습니다. 최대한 job을 나누고, 코드의 최적화를 시도했지만 계속해서 웹서버는 죽었고 결국 해당 기능을 잠시 죽이는 안타까운 백그라운드가 있었습니다Github https://github.com/today-they-learned/ttl_front https://github.com/today-they-learned/ttl_apiSellon 실시간 중고 상품 경매 서비스실시간성을 위한 API들을 어떻게 만들지에 대한 고민을 많이 한 프로젝트였습니다.자세한 내용은 Github README를 참고하면 될 것 같습니다.Github https://github.com/bunderLikeLion/sellon_frontend https://github.com/bunderLikeLion/sellon_backendPeacepiece 일상생활 속 환경을 위한 활동을 기반으로 가상공간을 꾸밀 수 있는 웹플랫폼기획자이면서, 디자이너이면서, 백엔드 개발자이면서, 프론트엔드 개발자였던 개인적으로 굉장히 힘들었던 프로젝트였습니다.Github (https://github.com/today-they-learned/peacepiece_front)[https://github.com/today-they-learned/peacepiece_front] https://github.com/today-they-learned/peacepiece_apiArmy Tiger 🪖 군대 일정을 Github 프로필에 남겨둘 수 있어요군대를 가면서, 여러 지인이 군대 일정에 대해서 물어보았습니다. 그러면서.. 한번 마지막 사이드 프로젝트로는 요걸 만들어봐야겠다는 생각이 들어서 바로 만들었습니다.만드는 김에 다른 사람들도 쉽게 사용하면 좋지 않을까 싶어서 사용법 등도 최대한 자세하게 작성했습니다.Github https://github.com/shinkeonkim/army-tiger혼세혼세한 개발 공부올해 계속 공부해온 것, 조금씩 찍먹을 해본 것, 공부해보려고 한 것들을 나열해보려고 합니다.군대를 다녀와서 어떤 걸, 어디서부터 시작할지 결정할때, 참고할 수 있지 않을까 싶습니다.[인프라] docker 기존에 서버에서 바로 웹 서버를 띄웠던 것들을 모두 Dockerize하여 구성하였습니다. 간단한 웹 서버를 구성해야할 때, 필요한 요소들을 템플릿화 하는 작업을 진행했습니다. 이후에는, 기본적인 auth API 및 문서화 등을 할 수 있는 템플릿까지 만들면 좋을 것 같습니다. docker-compose DB, Redis 등을 설치하여 구동하지 않고, docker container를 통해 구동하고, 이를 웹서버 등과 같이 사용하기 위해 docke-compose를 이용하였습니다. 캐싱같은 최적화를 좀더 찾아보면서 익힐 필요가 있을 것 같습니다. 최근에 docker-compose를 이용하여 개발을 할 때, alpha, beta, production 환경을 나누는 과정에서 좀더 간단하게 구성할 수 있는 방법을 찾고자 했지만 실패했습니다. 결국 파일을 모두 나누어 구성했습니다. 예를 들어, docker-compose.alpha.yml 라는 식으로.. 로컬에서 docker-compose를 이용하여 개발한 후, 이미지를 ECR에 올려서 ECS로 배포하는 작업을 시도했습니다. 이후에는 Terraform을 이용해 미리 인프라를 구성하고, 이 인프라와 함께 이 방식을 이용해보면 좋을 것 같습니다. k8s 회사 동료분이 쿠버네티스를 강력 추천하여, 공부를 해보고 있었습니다. 먼저, Django 웹 서버를 k8s에 얹어서 사용해보려 했지만.. 공부 기간이 너무 짧았습니다. 군대에 가서는 쿠버네티스를 공부하고 실제로 해볼 방법이 없을 것 같아, 잠시 보류하려 합니다. Terraform AWS 인프라를 구성할 때, 최대한 Terraform을 이용하여 구성하고자 했습니다. 인프라를 이전에 어떻게 구성했는지, 어떤 구성요소가 필요한건지에 대한 파악을 하기 쉬웠습니다. 다만, 어떤 오류가 발생하였을 때, Terraform이 바로바로 오류를 뱉지 않고 오랜 시간동안 기다리는 경우가 있어서 불편했습니다. 좀더 편한 방법을 공부해보면 좋을 것 같습니다. [웹 프레임워크] Rails 회사에서 계속 Rails를 이용한 개발을 했습니다. 최근에는 Service, Form 구조를 활용한 모듈 분리를 가장 많이 시도했습니다. 군대를 다녀와서도.. Rails가 여전히 살아있다면(제발) 토이 프로젝트로 Rails 개발을 해볼까 합니다. Django 사이드 프로젝트에서는 거의 Django를 활용했습니다. 웹 개발을 할 때, 가장 손에 익은 게 Python / Django 조합이었습니다. 하지만 대부분, drf를 계속해서 사용하는 반복적인 내용이었습니다. Django와 더불어 새로운 기술을 더 활용하는 프로젝트를 진행하면 좋을 것 같습니다. Koa.js 큰 이유 없이 제 영어 이름이 Koa이기에, 한번 이름값(?)해보고자 시작해봤습니다. 기존 Rails와 Django와 달리, node.js 진영의 웹 프레임워크들이 ORM을 쉽게 사용하는 방법이나, DB 마이그레이션을 효율적으로 관리하는 방법을 못 찾아서 그만두었습니다. 개발자에게 편리한 것이 많은 프레임워크들을 사용하다보니, 실망감이 컸던 것 같습니다. 나중엔 더 편해져있겠죠? Spring 이후에는 Spring도 사용하지 않을까하는 막연한 생각으로 공부를 해보려 했습니다. 인프런에서, 인프런 아이돌님의 강의를 쭉 듣고 있습니다. 생각보다 강의가 너무 많아서, 군대에서도 계속 들어보는 장기전이 될 것 같습니다. 처음에 강의를 들으면서 든 생각은, 이거 Django에서는 되게 쉽게 되는데.. 였지만, 일단 참고 들어보고 있습니다. [언어] ruby Rails를 하면서, 자연스레 루비 숙련도가 늘었습니다. PS를 할때도 ruby를 이따금씩 쓰기도 했습니다. single line if statement, ?/! method 등의 ruby에서 편한 문법을 좋아하게 되었습니다. 하지만, Rails가 없는 루비는 정말 불편했습니다. 이후에 어떻게 공부를 이어나가야 할지 감이 오지 않습니다. python python은 웹 개발 뿐만이 아니라 여러 분야에 다 활용했습니다. 로컬에서의 파일 정리등에도 말이죠. 하지만, pythonic 하게 코드를 짤 줄 아니? 라고 물어보면 No라고 답할 것 같습니다. Production Python 코드에 대한 경험이 적기도 하고, Python Senior 개발자들의 코드를 훔쳐?보는 경험을 할 기회가 별로 없었습니다. 좀더 심오하게 파고들 필요가 있습니다. rust 유데미 강의를 듣고 있었습니다. 군대를 가서도 해당 강의를 계속 듣지 않을까 싶습니다. C/C++ 개발자들이 Rust로 옮겨가고 있는 추세로 보였고, 왜 그런지를 알고싶었습니다. 웹 어셈블리를 이용한 웹 개발을 진행해보고 싶었습니다. c/c++ 알고리즘 문제 풀이에만 활용했습니다. c/c++로 production 코드를 개발하고 싶지는 않습니다. c/c++은 알고리즘 문제 풀이로만 활용하고 싶고, 이 생각은 변하지 않을 것 같습니다. [PS / 알고리즘] 아직 PS(Problem Solving) / 알고리즘 공부를 놓지 못했습니다. 주로 BOJ와 Solved.ac를 이용해 문제를 풀었습니다. Codeforces나 Atcoder는 자신감이 부족해서 문제 수 4,000 문제와 다이아 3 달성하기 전까지는 안할려 합니다. 기본 구현 문제 최근에 Production 코드에 집착을 하다보니, 기본 구현 문제를 빠르게 생각하고 짜지 못하는 것 같았습니다. 그래서 최대한 Bronze, Silver 문제들을 가볍고 빠르게 짜는 연습을 했습니다. 문자열 구현 문제들을 풀면서, 많은 기본 문제를 풀게 되었습니다. 하지만, 기본적인 KMP, Trie 등을 활용하는 문제를 최근에 안 풀어서, 숙련도가 낮아졌습니다. 예전부터 문자열 문제에는 손이 안가는 것 같습니다. DFS / BFS solved.ac 에서 lang:ko tag:dfs - @$me 라는 식으로 검색하여, 한국어 DFS 문제 중 내가 안 푼 문제를 검색하여, 난이도 순으로 쭉 풀고 있었습니다. 채용 코테 또는 알고리즘 대회 등에서도 DFS/BFS는 무조건 한번은 나온다는 생각이 있기 때문에, 최대한 빠르고 정확하게 짜는 연습을 해보고 있습니다. 생각보다 DFS가 많은 알고리즘의 기초라는 사실을 종만북을 다시 읽다가 깨닫게 되어서, 깊게 파보고 있습니다. 트리 트리와 쿼리 시리즈를 계속 풀어보려고 트리 알고리즘들을 공부해보고 있었습니다. 하지만.. 트리랑은 제 머리가 맞지 않나 싶을 정도로 안 풀렸지만요.. 일단 LCA / Sparse Table 들을 활용하는 기본 트리 문제를 다 풀어서, 배수진을 칠까 합니다. 기하 기하는 알면 쉽지만, 모르면 못푸는 문제가 너무 많습니다. 이차원 벡터 등의 구현체들을 하나씩 만들어두면서 활용하고 있습니다. 최근에 볼롤껍질, 회전하는 캘리퍼스 문제를 다시 풀어봤습니다. 역시나 알고나면 너무 쉬운 문제였습니다. 정수론 대학에서도 수학 공부를 별로 안했는데, 알고리즘 문제 풀겠다고 수학 공부를 하고 있는 저를 보고 참 웃겼습니다. 정수론 책들을 사서까지 보고 있었는데, 군대가서 아마 요 책들을 읽지 않을까.. 싶네요.. 하하.. 탐색 몇달전에야 삼진탐색을 제대로 알게 되었습니다. 하지만 카테고리를 보지않고 “이 문제 삼진 탐색이다!”하는 연습은 더 필요할 것 같습니다. 아직 이진탐색을 알아채는 것도 좀 늦는 것 같습니다 ㅠ DP DP 문제들을 보고, 와 이거 DP다! 를 알아채는 시간은 줄었지만, 빠르고 간결하게 짜는 걸 더 연습해야 합니다. 그리고 한번 긁어서 되는 기본적인 DP 문제들보다, 이제 DP 최적화 기법들을 공부해봐야 할 것 같습니다. 아마 koosaga 님의 글을 참고해서 더 공부해야할 것 같습니다. 세상에, 너무 공부할게 많네요. 자격증을 땄다?COS Pro 1급 Python과 정보처리산업기사를 땄습니다.두 자격증을 따는 데, 긴 기간을 쓰지는 않았습니다.Cos Pro는 시험 전날에 무슨 문제가 나왔었나 찾아보는 정도였고,정보처리산업기사는 필기 한달, 실기 2주정도 자격증 책을 보고 공부(라고 하고 암기)했습니다.기존에 알고리즘이나 CS를 계속 공부하고 있던지라 그렇게 어렵지는 않았습니다.AWS 자격증도 따고 가고 싶었는데, 점점 미루고 미루다가 못 따고 가네요..결론올해는 일 / 사이드 프로젝트 / 알고리즘 공부 / 유튜브, 넷플릭스 / 잠 의 반복이었지 않나 싶습니다.곧, 군대에 입대합니다. 내년에는 회고록을 쓸 수 있을지 잘 모르겠습니다.군대에 있으면서 시간이 날 때마다 개발 공부를 하고는 싶습니다.. 하게 된다면 그 내용들을 정리하는 글을 써봐도 좋을 것 같습니다.아무튼 다치지 않고 군대 잘 다녀오겠습니다.충성." }, { "title": "[BOJ] 16942 문자열 접기", "url": "/posts/boj-16942/", "categories": "BOJ", "tags": "BOJ, PS, DP", "date": "2022-05-05 12:16:14 +0900", "snippet": "문제 요약 및 풀이16942번: 문자열 접기주어지는 문자열을 접어서, 같은 문자열로만 이루어지는 문자열을 만들어내면 된다.문제에서 주어지는 예시를 쭉 보다보면, 한가지 사항을 발견할 수 있다.만들어내는 문자열의 각 문자의 원래 문자열에서의 위치는 서로 홀수만큼 차이가 난다. (사이에 있는 숫자 갯수를 말하는 것이 아닌, 위치의 차이다.)따라서, 최대한 같은 문자를, 위치가 홀수만큼 차이가 나는 문자들을 선택하면 된다.물론 하나하나 따져가면 시간초과가 뜰테니.. DP로 풀어나갔다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i &amp;lt; n; i++)#define for1j(s,n) for(int j = s; j &amp;lt; n; j++)using namespace std;string s; // 입력받을 문자열int d[1100], ans; // d: DP 배열, d[i] = i번째 문자를 사용했을 때, 만들 수 있는 최대 문자열 길이int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; s; int n = s.length(); for1(0, n) d[i] = 1; // 어찌되었든, 문자열을 접지 않으면, 모든 문자가 1로 가능하다. for1(1, n) { for1j(0, i) { if((i - j) % 2 &amp;amp;&amp;amp; s[i] == s[j]) { // 홀수 간격이고, 문자가 같은 경우 d[i] = max(d[i], d[j] + 1); } } } for1(0, n) { // DP 배열에서 최대값을 뽑아낸다. ans = max(d[i], ans); } cout &amp;lt;&amp;lt; ans;}" }, { "title": "[BOJ] 19718 King&#39;s Inspection", "url": "/posts/boj-19718/", "categories": "BOJ", "tags": "BOJ, PS, Greedy", "date": "2022-01-08 18:33:10 +0900", "snippet": "문제 요약 및 풀이19718번: King’s Inspection문제 상황을 요약하면 다음과 같다.자연수 a,b,c 가 주어진다.주어진 자연수 a, b, c중 2개를 골라 1씩 더할 수 있다.이때, 모든 숫자를 같게 만들기 위한 최소 덧셈 횟수는 몇번인가?풀이 코드문제를 보자마자, 바로 드는 생각은그때 그때 가장 작은 숫자 2개를 골라 1씩 더해주면서 카운팅하면 되지 않을까? 였다.그래서 바로 아래와 같은 풀이를 작성했다.l = [int(input()) for i in range(3)]cnt = 0while not l[0] == l[1] == l[2]: l.sort() l[0] += 1 l[1] += 1 cnt += 1print(cnt)(브론즈 2티어 문제라서 그렇게 어려운 풀이를 유도하지는 않을 거라 생각했고, 범위도 신경쓰지 않는 풀이를 작성해버렸다.)역시 위 풀이는 시간초과가 발생했고, 시간초과를 보고 나서 a, b, c의 최대 범위가 5억이라는 것을 확인했다.그래서 이제 간단하게 또 생각을 틀었다.가장 작은 2개가 서로 같지 않다면 그 두 개를 격차만큼 더해주고, 같다면 가장 큰 수와의 격차를 더해주면 되지 않을까?그리고 아래와 같은 풀이를 작성했다.l = [int(input()) for i in range(3)]cnt = 0while not l[0] == l[1] == l[2]: l.sort() if l[1] != l[0]: diff = l[1] - l[0] else: diff = l[2] - l[1] l[0] += diff l[1] += diff cnt += diffprint(cnt)하지만… 여기서 끝나지 않았다..바로 아래와 같은 케이스에서 너무나 늦게 답이 수렴되었기 때문이다.1499999999500000000다시 한번 생각을 틀었다.무조건 작은 2개를 뽑는 게 아니라,먼저 큰 두 숫자의 격차를 더해주고, 그 두 숫자가 같다면(격차가 0이라면) 작은 2개의 격차를 더하자.l = [int(input()) for i in range(3)]cnt = 0while not l[0] == l[1] == l[2]: l.sort() diff = l[2] - l[1] if l[2] - l[1] else l[1] - l[0] l[0] += diff l[1] += diff cnt += diffprint(cnt)단순하게 어떤 숫자를 선택해야 격차를 빨리 좁혀서 더해나갈 수 있을지 생각을 했고, 요렇게 AC를 받았다.끝" }, { "title": "[TIL] Window size에 따라 속도가 달라지는 CSS Animation 바로잡기", "url": "/posts/TIL-responsive-animation/", "categories": "TIL", "tags": "TIL, CSS, CSS Animation, Vue.js", "date": "2021-12-19 18:38:16 +0900", "snippet": "문제 상황새벽에 어쩌다 떠오른 아이디어로 짧고 굵게 토이 프로젝트를 진행해보고 있다.Github repoSite page바로 Can you catch “Circle” 이다. 뭐.. 줄이자면 CCC 일 것 같다. ㅋㅋㅋ굉장히 단순한 웹 페이지 프로젝트이다.단순히 화면에 있는 “Circle”을 잡으면 된다.아직은 좌우로 움직이는 기믹밖에 없지만, 점차 추가해보려고 한다.아무튼, 방금 언급한 “좌우로 움직히는 기믹”을 만들던 중, 아래와 같은 코드에서 한가지 생각지도 못했던 이슈가 발생했다..move-left-to-right { animation: just-left-to-right 20s linear infinite; -webkit-animation-name: just-left-to-right; -webkit-animation-duration: 20s; -webkit-animation-timing-function:linear; -webkit-animation-iteration-count: infinite;}@keyframes just-left-to-right { 0% { transform: translateX(-45vw); } 50% { transform: translateX(45vw); } 100% { transform: translateX(-45vw); }}@-webkit-keyframes just-left-to-right { 0% { -webkit-transform: translateX(-45vw); } 50% { -webkit-transform: translateX(45vw); } 100% { -webkit-transform: translateX(-45vw); }}바로 모바일과 PC에서의 화면 크기 차이 때문에 Circle이 다른 속도로 움직인다는 것이다.왤까? 오랜만에 간단한 물리 식 \\(V(속력) = D(거리) / T(시간)\\) 을 떠올려보자.여기서 거리는 \\(90vw * 2\\) 일 것 이다.(왕복 거리) 그리고 시간은 20초이다.한가지 의문이 들 수 있다. 어? 수치가 정해져있는데, 속력이 고정되어있는 것 아닌가요?아니다vw 는 화면 크기에 따라 달라지는 가변단위 이기 때문이다.따라서, 자연스럽게 화면 크기가 커지면 속력이 증가하고, 화면 크기가 작아지면 속력이 감소한다.그래서 모바일에서 보면 굉장히 굉장히 느려지는 이슈가 발생한 것이었다.그럼 어떻게 고쳤나?여러 가지로 시도해봤지만 SCSS에서 가져온 window width를 시간 개념으로 다시 convert 하는 방법을 찾지 못했다.그래서 해당 프로젝트는 Vue.js 프로젝트였기 때문에, js 단에서 속도를 정의하고 이걸 template에 주입하는 방식으로 해결했다.솔직히 마음에 드는 방법은 아닌지라, 조금이라도 더 좋은 방벙을 발견하면 고칠 것 같다.아래 코드가 해당 문제를 해결한 수정 내용이다. (해당 글과 상관없는 내용과 위에 첨부한 style 부분은 생략했다.)&amp;lt;template&amp;gt; &amp;lt;Circle class=&quot;move-left-to-right&quot; :style=&quot;`animation-duration: ${compuetedAnimationDuration}s;-webkit-animation-duration: ${compuetedAnimationDuration}s;`&quot; /&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { computed, defineComponent, inject, onMounted, ref,} from &#39;vue&#39;import Circle from &#39;@/components/Circle.vue&#39;export default defineComponent({ name: &quot;JustMovingPage&quot;, setup() { const VELOCITY = 150; const windowWidth = ref(1); const compuetedAnimationDuration = computed(() =&amp;gt; windowWidth.value / VELOCITY); onMounted(() =&amp;gt; { windowWidth.value = window.innerWidth; window.onresize = () =&amp;gt; { windowWidth.value = window.innerWidth; } }) return { windowWidth, compuetedAnimationDuration, } }, components: { Circle }})&amp;lt;/script&amp;gt;참고한 글Stackoverflow: Set reactive screen width with vuejs" }, { "title": "[TIL] Django Alphanumeric Random String 생성하기", "url": "/posts/TIL-django-get_random_string/", "categories": "BOJ", "tags": "TIL, python, Django, random", "date": "2021-12-14 21:40:53 +0900", "snippet": "Django에서 랜덤 문자열 쉽게 만들어내기웹 서비스를 구성하다보면, 종종 랜덤 문자열을 뽑아내야 하는 경우가 있다.이번에는 사용자가 직접 가입하지 않고 초대를 받아 가입하는 서비스를 구성하던 중에, 임의적으로 유저의 username을 설정해야 했다.이전에는 random module을 이용해 작성했지만, 이번에는 Django에서 지원하는 모듈로 작성하고자 찾아봤다.get_random_string바로, get_random_string이다.아래와 같이 import 하면 된다.from django.utils.crypto import get_random_string사용방법 length를 무조건 넘겨주어야 한다. get_random_string(length=10) allowed_chars를 이용해서 랜덤으로 뽑아낼 문자의 후보를 한정할 수 있다. get_random_string(length=10, allowed_chars=&quot;ABCD&quot;) 번외로 말하면 allowed_chars는 아래와 같이 하드코딩되어서 들어가고 있는 구조이다. RANDOM_STRING_CHARS = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39; def get_random_string(length=NOT_PROVIDED, allowed_chars=RANDOM_STRING_CHARS): 따라서, 아래와 같이 allowed_chars를 한글로 대체하여 한글 랜덤 문자열을 자연스럽게 뽑아낼 수도 있다. get_random_string(3, &quot;가나다&quot;) " }, { "title": "대학교 2학년 휴학생, 회사에서 2021년 회고록", "url": "/posts/goodbye-2021/", "categories": "회고록", "tags": "회고록, 주니어 개발자", "date": "2021-12-09 00:00:00 +0900", "snippet": " 한달, 아니 적어도 분기마다 회고록을 쓰려고 했지만.. 항상 키보드를 잡다가, 포기해왔다. 하지만 올해는 마무리 지어야하기에 끄적여본다.🚀 왜 휴학하고 회사를 다니게 되었을까?전 19학번으로 대학교에 입학했습니다.그리고 우연히, 정말 우연한 기회로 그렙이라는 회사에서 1학년 여름방학 인턴을 하게 되었었습니다. 알고리즘 컨텐츠 제작자로 근무를 했고, 그렇게 1학년 겨울방학, 2학년 여름방학까지 알고리즘 컨텐츠 제작자로 근무했습니다.그러던 중, 알고리즘 컨텐츠 제작자로 근무를 하는 건, 나에게 의미가 있을까? 지금 하고 있는 이 경험은 나에게 새로운 자극을 주는 경험일까?라는 의문이 들었습니다.그리고 2학년 겨울 방학에는 꼭 &quot;개발자&quot; 인턴을 경험해보자 생각을 했고, 바로 도전해봤습니다. 여러 곳에 서류를 넣었고 면접을 봤었지만, 결국 한번 더 가장 좋은 조건과 기회를 제공해주신 그렙에서 2020년 12월 부터 개발자로 근무를 하게 되었습니다.근무를 시작하기 전, 2학기 기말고사를 마무리 짓고 부리나케 그렙에서 사용하는 Ruby on rails 기술스택을 익히기 시작했습니다.Ruby on rails을 익히기 위해서, 책도 찾아보고, 여러 글도 찾아보았지만, 결국 가장 좋은 것은 공식 문서였습니다. 책과 공식문서를 읽어가면서 일주일동안 Ruby on rails 스택을 익혔습니다. 어쩌면 이전부터 계속 사용하던 주 스택이 Django였던 지라 익숙함을 느끼며 금방 습득했던 것 같습니다.인턴으로 입사한 후, Ruby on rails를 활용하는 간단한 업무를 주셨고 빠르게 내부 레거시를 습득하면서도 Ruby on rails를 공부할 수 있는 기회를 얻을 수 있었습니다. (이후엔 여러 주니어 개발자분들이 비슷한 시기에 입사하셔서 같이 레일즈스터디를 이어갔고, 이게 큰 도움이 되었습니다.)그렇게 계속 열심히 일을 하던 중에 1월 쯤, 경영진의 정규직 제안을 받게 되었습니다. 여기서 굉장히 고민을 많이 하게 되었습니다. 1년에서 2년 가량의 경력을 대학교 중간에 쌓을 수 있는 기회가 생각보다 크게 다가왔고, 그렇기엔 아직 졸업을 못한 저 자신이 너무 부담스럽기도 했습니다.그래도.. 지금 당장 제가 재밌고, 할 수 있는 것을 하자는 생각으로 학교를 휴학하고(때려치우고 ?!) 2021년을 그렙에서 보내게 되었습니다. 🥰🌱 1년동안 어떻게 성장했나?🦁 아직 손에 쥐고 있었다. 동아리 활동학교를 갑작스럽게 휴학하게 되면서, 원래 하고 있던 동아리 활동에 영향을 주게 되었습니다. 2021년에는 국민대학교 멋쟁이사자처럼 운영진 대표로서 역할을 다하기로 하였었지만, 학교를 다니지 않게 되면서 적지 않은 영향을 주게 되지만, 코로나의 영향으로 비대면 활동을 이어가게 되면서 회사와 동아리 활동을 이어갔습니다.먼저, 국민대학교 멋쟁이사자처럼에서 주마다 HTML, CSS, Django 관련 세션을 이어갔고, 이를 준비하는 과정에서 다시 한번 Django에 대한 지식을 점검할 수 있었습니다.그리고 다른 사람들에게 제 지식을 전파하는 경험을 하게 되었습니다.🥊 재미있는 프로젝트를 많이 해보자.전 친구들이 취미가 뭐라고 물어보면, 뭔지 알잖아? 개발 이라고 답해왔는데, 이번년도에도 시간이 날때마다 토이 프로젝트를 하려고 해왔습니다. 일단 정리 겸, 한번 나열해보겠습니다. 🧐나열을 해보니, 생각보다 올해 일단 많은 프로젝트/아이디어를 내놓으려고 했던 것 같습니다.. 내년엔 조금 더 완성도 있는 프로젝트들을 내놓아보는 걸 목표로 해보고 싶습니다.Django Coffee Modelgithub: django-coffee-model 오픈소스 프로젝트timestamps를 조금더 쉽게 사용할 수 있게 만들어주는 단순한 django 라이브러리 입니다.pypi에 배포하였고, 이후 제가 만드는 프로젝트들에서도 사용하면서 유지보수를 했습니다. (물론 첫번째 오픈소스라서 나중에 다 갈아엎고 싶을 정도로 버전 관리를 엉망으로 한 것 같습니다.)팩토리 유튜버의 영상 삭제를 막아보자!github: prevent-factory-video-deletion 프로젝트유튜버 팩토리 님의 영상을 보고 시작하게 된 프로젝트입니다.영상의 주요 내용은, 해당 영상에 60분마다 댓글이 달리지 않으면 영상을 삭제하겠다는 내용입니다. 이걸 보고 전, 어? 깃헙 액션에 cron job 기능도 생겼는데, 이걸 한번 써서 크롤링해볼까? 라는 생각을 했고, 바로 코드로 옮겨봤습니다. 하지만.. 로컬에서 작동하던 코드가 깃헙 액션으로 옮겨지니 크롤링이 잘 되지 않는 모습을 보였습니다. ㅠㅠ. 유튜브 사이트 내부에서 크롤링을 막기 위해 무언가를 해둔 것 같았지만.. 해결하지 못하고 이 프로젝트는 멈추게 되었습니다.Github action을 이용해 슬랙에 주기적으로 메세지를 보내보자!github: kmu-likelion-slack-noti-action 프로젝트이전 글에서 다루었던, 프로젝트입니다.아래 글을 참고해주세요.글 보러 가기무야~호github: mooyaho 프로젝트2021년 초, 한동안 무야호 밈이 유행했었습니다. 한번 짤생성기를 경험삼아 Vue.js로 간단하게 만들어볼까 하고 시도한 프로젝트입니다.그냥 살짝 맛만 보고.. 더이상 개발하지 않아서, 조금 아쉬운 프로젝트인 것 같습니다.아직도 돌아가고 있는 허접한 사이트 보러가기 - https://mooyaho.me/대학생 멋쟁이사자처럼 프로필을 이쁘게 보여주는 프로젝트github: likelion-badge 프로젝트해당 프로젝트는 Github README에서도 언급되어있듯이 mazassumnida 프로젝트를 보고 영감을 받아 진행해본 프로젝트입니다.단순히, 멋쟁이사자처럼 기수와, 대학교 영어명을 param으로 넘기면 원하는 뱃지를 svg로 얻어내는 사이트를 만들고 배포했습니다.해당 배지를 주로 Github Profile README나 노션 이력서 등에 첨부하는 것을 의도한 프로젝트입니다.해커톤을 운영하면서, 정해진 기간에 개발된 프로젝트가 맞는지 알아야 했다!github: github-repository-start-date-checker하반기 중에, 멋쟁이사자처럼 대학교들이 모여 연합해커톤을 여는데, 어흥올림픽 이라는 해커톤 운영진으로 참가하게 되었습니다.해커톤 운영 규칙중, XX월 OO일 이전부터 시작된 프로젝트는 인정하지 않습니다. 라는 식의 규칙이 있었고, 이를 검증할 방법이 필요했습니다.다른 운영진분께서 크롤링을 이용한 코드를 작성해주셨고, Github API를 이용하는게 더 편하지않을까? 라는 생각이 들어서 이를 리팩토링하여 프로젝트를 간단하게 구성하고 실제로 활용했습니다.바빠도 해커톤은 참가해야지github: 대동먹지도 프로젝트멋쟁이사자처럼 중앙 해커톤을 멋쟁이사자처럼 구성원분들과 같이 참가하게 되었고, 대동먹지도라는 프로젝트를 진행했습니다.정말 사소한 먹거리들을 서로 공유하는 플랫폼을 만들어보자는 아이디어였고, 아쉽게도 수상하지는 못했습니다.백엔드는 Django,(Django rest framework) 프론트엔드는 React,js로 구성했던 프로젝트입니다.저는 백엔드, 프론트엔드 전반적인 구조를 구성하고, 각 환경을 배포하는 역할을 맡았습니다.이 플젝을 하면서… Django Rest Framework를 전보다 훨씬 빡세게 써볼 수 있었습니다.(문서화, Class based View 등등..) React.js에서는 Redux를 통한 상태관리를 어떻게 더 잘할 수 있는지 알 수 있게 되었습니다.⌨️ 코드 리뷰는 정말로 소중했다.1년동안 그렙을 다니면서, 절 가장 성장시킨 존재는 코드 리뷰인 것 같습니다.이전에는 코드 리뷰는 어떻게 하는거지? 왜 하는거지? 등등 머리속에 의문만이 가득한 존재였지만, 지금은 꼭 있어야 하는 존재로 저에게 남았습니다.먼저, 코드 리뷰를 하면서 받았던 피드백들을 따로 모아두고, 기억하면서 비슷한 상황이 나왔을 때, ‘아, 이전엔 이렇게 했었지?’ 하는 도움말이 생겼습니다.그리고 어떻게 효율적으로 짤 수 있을지, 어떻게 다른 사람이 봐도 이해가 되는 코드 구조를 구성할 수 있을지에 대한 고민을 하는 능력을 기를 수 있었습니다.또한, 저의 코드 뿐만 아니라, 다른 사람이 구성한 코드를 볼 때도 새로운 지식들을 배울 수 있었고, 실제로 배운 것들을 써먹기도 하면서 좋은 코드들을 습득하는 기회를 가질 수 있었습니다.(다음 회사, 다다음 회사를 가더라도, 전 꼭 코드 리뷰가 있고 자유로운 개발문화를 가진 회사를 가야겠다는 다짐도 하게 되었습니다.)🗓 1일 1 OO올해까지 해서, 현재 대력 2년간 1일 1커밋을 이어왔습니다. (아직 올해가 다 가지 않았지만..)대략 2019년 12월 부터 시작한 1일 1커밋을 지금까지 이어온 것이 되게 뿌듯하네요.주변에서, 이따금 계속 1일 1커밋 하기 힘들지 않냐라는 질문을 주시긴 합니다.저도 처음 1일 1커밋을 시작했을 때는 너무나 힘들었던 것 같습니다.&quot;할 커밋이 없었으니까요.&quot;아는 것도 얼마 없고, 프로젝트는 당연히 진행하고 있지 않았습니다.그래서 무작정 알고리즈 문제를 풀고 이것부터 커밋하는 습관을 들이기 시작했습니다. 점차 커밋에 대한 부담감이 줄어들었고 여러 지식을 얻어가면서 프로젝트도 시작해갔습니다.그렇다보니 요즘 평소 제 생활을 하다보면 어느새 하루에 1일 1커밋이 되어있는 것 같습니다. 평일 낮에는 일을 하고, 밤에는 프로젝트를 하고, 주말에는 프로젝트/공부를 하니까요.그리고 1일 1커밋을 이은 1일 1문제를 시도하고자 하고 있습니다.solved.ac에서는 백준 문제를 풀고 이를 스트릭으로 나타내주고 있습니다. 이를 이용해서 잔디를 또 채워보고 있습니다.이전에 1일 1커밋을 했을 때처럼, 지금은 쉬운 문제들로만 시도해보고 있습니다. 처음부터 어려운 문제들로 채워나가기엔 저에게 너무나 큰 스트레스를 줄 것 같았습니다.지금은 습관만 가지자는 마음으로 브론즈 문제들로 채워가고 있고, 점차 풀 문제가 사라지면 난이도를 하나씩 올려가면 문제들을 계속 풀어나가보려 합니다.내년엔 무슨 성장을 할까?Django/Rails/AWS를 좀 더 깊게 파보자.내년엔 조금 더 깊게 Django/Rails/AWS를 파보려고 합니다.Django/Rails에 대해서는 아직까지 계획이 크게 없지만 더 Production에 맞는 코드를 구성하는 방법에 대해서 파볼까 계획 중입니다.AWS는 관련 자격증을 따면서 공부하려고 합니다. 하지만..안타깝다.안타깝게도 내년엔 성장을 할 수 있는 기간이 짧을 것 같습니다.저는 현역 판정을 받은 21세 (2021 기준)이고, 군대를 더이상 미룰 수 없다는 판단을 했고, 하반기 혹은 내후년 상반기 중에는 군대를 가야할 것 같습니다.자격증을 따자.앞서 말한 군대를 위해, 여러 자격증을 딸 생각이다. 단순히 군대를 위한 자격증만은 아니고, 이후 내 커리어를 위해서도 필요하겠다 싶은 자격증들을 하나씩 모아두려고 한다. Cos Pro 정보처리산업기사 AWS Certified Developer - Associate SQLD 기타..?조금 더 기록을 할 수 있는 방법이 없을까?군대를 가더라도.. 아마 휴대폰은 쓸 수 있을 것 같고.. 미래의 저를 위해서 휴대폰에서도 쉽게 제가 현재 가지고 있는 지식을 계속 볼 수 있게 만들어보고 싶습니다.아마 블로그에 글을 계속 쓰는 것으로 할 것 같지만.. 조금 더 부담감없는 방법이 없을까? 생각을 더 많이 해봐야 할 것 같습니다.결론올해 주니어 개발자로서 성장을 계속 해보자는 마음으로 살아온 것 같습니다.내년에는 더 깊은 분야로 빠져드는 공부를 해보고 싶지만, 이제 새로운 도전을 해야 하는 시점에 왔기에 어떤 변곡점이 생길지 모르겠습니다.지금처럼 행복하고 만족스러운 개발을 이어가는 개발자가 되고 싶습니다.끝." }, { "title": "[TIL] 슬랙 웹훅과 깃헙 액션을 이용해 알림 봇 만들기", "url": "/posts/TIL-slack-web-hook-and-github-action/", "categories": "TIL", "tags": "TIL, 슬랙 webhook, Github action", "date": "2021-11-18 20:02:09 +0900", "snippet": "계기국민대학교 멋쟁이사자처럼에서 슬랙을 사용하기로 했고, 내부 스터디인 줌터디도 슬랙에서 활동을 하게되었다.이때, 특정 시간마다 회고글을 쓰라는 메세지가 주기적으로 오는 봇이 있으면 좋겠다고 생각이 들었다.그래서 바로 워크플로빌더를 켰지만… 무료 플랜에서는 사용할 수 없었다…그래서 직접 만들자! 결심했다.일단 먼저 슬랙에 메세지를 보내기 위해, Slack Incoming Webhook을 설정했다.큰 이슈는 없고, 딱 Webhook URL만 알아내면 된다. (간단해서.. 스킵..)그리고 이제 주기적으로 메세지를 보내는 환경을 만들어야 한다.cron job을 실행할 서버가 따로 있을까 고심하던 중, Github Action을 떠올렸고 구글링을 해서 간단한 파이썬 프로젝트를 구성했다..github/workflow/python-apps.ymlname: Noti Zoom Studyon: schedule: - cron: &quot;0 11 ? * SUN&quot; workflow_dispatch:jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set up Python 3.10 uses: actions/setup-python@v2 with: python-version: &quot;3.10&quot; - name: Install dependencies run: | python -m pip install --upgrade pip if [ -f requirements.txt ]; then pip install -r requirements.txt; fi - name: Noti run: python actions/zoom_study_notice.py env: ZOOM_STUDY_WEBHOOK_URL: $actions/zoom_study_notice.pyimport os, syssys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))from dotenv import load_dotenvfrom api.slack import post_textload_dotenv(verbose=True)ZOOM_STUDY_WEBHOOK_URL = os.environ.get(&quot;ZOOM_STUDY_WEBHOOK_URL&quot;)ZOOM_STUDY_NOTICE = &quot;&quot;&quot;&amp;lt;!channel&amp;gt; 이번주가 지났습니다.1. 한 주동안 달성하고자 하는 목표를 적어주세요.2. 지난 일주일동안의 목표 달성률과 그 이유를 적어주세요[예시]😀 이번주 목표 - 도메인 주도 설계 책 4챕터까지 읽기🤗 지난주 달성 - 75/100, 3챕터까지 다 읽고자했지만, 못 읽었다.😉 목표의 방향은 정해져있지않아요.🙃 스스로 할 수 있는 목표치를 정해보아요.😇 매주 목표를 정하고, 점검해보아요🥰 목표가 많다면 여러개를 적어도 돼요&quot;&quot;&quot;if __name__ == &quot;__main__&quot;: ret = post_text(ZOOM_STUDY_WEBHOOK_URL, ZOOM_STUDY_NOTICE) print(ret) 참고한 블로그 Github Repository 이번에 cron을 쉽게 만들려고 알아보던 중에, cronmaker라는 사이트를 처음 알게 되었다. cron 정규 표현식을 더 쉽게 만들어준다.메세지가 잘 온다!" }, { "title": "[BOJ] 15087 DRM Messages", "url": "/posts/boj-15087/", "categories": "BOJ", "tags": "BOJ, PS, 구현", "date": "2021-11-08 15:42:51 +0900", "snippet": "문제 요약 및 풀이15087번: DRM Messages python에서 ord, chr을 잘 활용하자. 단계별로 최대한 함수를 나누어 구현해보면, 더 쉽게 문제가 해결된다.풀이 코드def get_sum(s): return sum([ord(i) - 65 for i in s])def rotate_chr(s, n): return chr((ord(s) - 65 + n) % 26 + 65)def divide(s): return s[: len(s) // 2], s[len(s) // 2 :]def rotate(s, n): return &quot;&quot;.join([rotate_chr(i, n) for i in s])def merge(a, b): return &quot;&quot;.join([rotate_chr(a[i], ord(b[i]) - 65) for i in range(len(a))])s = input()s1, s2 = divide(s)print(merge(rotate(s1, get_sum(s1)), rotate(s2, get_sum(s2))))" }, { "title": "[BOJ] 9881 Ski Course Design", "url": "/posts/boj-9881/", "categories": "BOJ", "tags": "BOJ, PS, sweeping", "date": "2021-10-23 17:05:14 +0900", "snippet": "문제 요약 및 풀이9881번: Ski Course Design문제를 간단?하게 요약/번역해보자.땅의 높이를 나타내는 숫자 n개가 주어진다.각 땅의 높이를 낮추거나 높일 수 있을 때, &quot;가장 높은 땅의 높이&quot;와 &quot;가장 낮은 땅의 높이&quot;의 격차를 17보다 작거나 같게 만들어야 한다.이때, 총 비용을 구해야 한다. 단, 각 땅의 높이를 k만큼 낮출 때 비용은 k*k이다.얼핏보면 심플해보이지만, 아래 테케와 같은 경우523202124작업 후, 전체 높이가 [4, 4, 20, 21, 21] 와 같이 될 때 최소다. 특정 최소 지점과 최대 지점만 잡고 계산하면 안 된다는 의미이다.(제 풀이는 다른 분들의 풀이와 다른 것 같다; 문제 풀이 보기를 하니 제가 너무 꼬아서 풀었던 것 같다 ㅠ)그래서 일단 정렬을 기본으로 하고,두 왼쪽, 오른쪽 구간을 설정하고, 각각의 구간에 포함되어있는 숫자는 모두 같다고 가정했다.왼쪽 구간은 무조건 증가시키는 구간, 오른쪽 구간은 무조건 감소시키는 구간으로 생각하였고, 아직 왼쪽 구간과 오른쪽 구간의 격차가 17 이상이라면 증가/감소 액션을 수행했다.증가, 감소를 수행하는 기준은 (증가/감소시키므로서 될 코스트 - 현재까지의 코스트)를 구해서 더 코스트가 작은 액션을 수행하게 했습니다.풀이 코드n = int(input())height = sorted([int(input()) for i in range(n)])cost = [0]*nl = 0 # 왼쪽 구간은 오른쪽 끝만 알고 있으면 된다.r = n-1 # 오른쪽 구간은 왼쪽 끝만 알고 있으면 된다.# 초기 왼쪽 구간을 설정한다.for i in range(n): if height[i] == height[0]: l = i# 초기 오른쪽 구간을 설정한다.for i in range(n-1, -1, -1): if height[i] == height[-1]: r = iwhile l &amp;lt; r and height[r] - height[l] &amp;gt; 17: l_cost = 0 r_cost = 0 # 왼쪽 구간을 증가시킴으로서 발생하는 비용 측정 for i in range(l+1): l_cost += (cost[i]+ 1)**2 - cost[i]**2 # 오른쪽 구간을 감소시킴으로서 발생하는 비용 측정 for i in range(n-1, r-1, -1): r_cost += (cost[i]+1)**2 - cost[i]**2 if l_cost &amp;lt; r_cost: # 왼쪽 구간의 비용이 작은 경우 증가 액션 수행 for i in range(l+1): cost[i] += 1 height[i] += 1 else: # 오른쪽 구간의 비용이 작은 경우 감소 액션 수행 for i in range(n-1, r-1, -1): cost[i] += 1 height[i] -= 1 # 숫자를 증가시킴으로서, 구간이 확장되어야 하는지 검사 for i in range(n): if height[i] == height[0]: l = i # 숫자를 감소시킴으로서, 구간이 확장되어야 하는지 검사 for i in range(n-1, -1, -1): if height[i] == height[-1]: r = iprint(sum([i*i for i in cost]))끝" }, { "title": "[BOJ] 14427 수열과 쿼리 15(2)", "url": "/posts/boj-14427-2/", "categories": "BOJ", "tags": "BOJ, PS, 수열과 쿼리, priority_queue", "date": "2021-10-17 11:42:08 +0900", "snippet": "문제 요약 및 풀이14427번: 수열과 쿼리 15(2)boj-14427 글에서 평방 분할을 이용한 풀이를 끄적였는데, solved.ac 난이도 기여를 하러 들어갔더니대부분의 의견이 세그먼트 트리 기준으로 난이도 기여를 하지말아달라는 것이었다.왤까 생각을 해보니.. 이 문제는 priority_queue로 간단하게 해결된다.일단, 다른 수열과 쿼리 문제와 다르게 이 문제는 특정 구간을 구하는 쿼리가 아닌 전체 구간의 최소값을 구하는 것이다.따라서 세그먼트 트리나 평방 분할같이 특정 구간의 대표값을 알아내는 쿼리 자료구조/알고리즘을 쓸 필요가 없었다.그냥 값들을 모조리 priority_queue에 넣어두고, 현재 해당 인덱스에 들어가있는 값과 priority_queue의 top()의 값이 제대로 성립하는지 확인하면서 top()값들을 출력하면 되었다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i&amp;lt;n; i++)using namespace std;typedef long long ll;typedef pair&amp;lt;ll, ll&amp;gt; pll;priority_queue &amp;lt;pll, vector&amp;lt;pll&amp;gt;, greater&amp;lt;pll&amp;gt;&amp;gt; Q;ll N, M;ll ar[110000];ll q, a, b;int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N; for1(0, N) { cin &amp;gt;&amp;gt; ar[i]; Q.push({ ar[i], i}); } cin &amp;gt;&amp;gt; M; while(M--) { cin &amp;gt;&amp;gt; q; if(q == 1) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; a--; ar[a] = b; Q.push({b, a}); } else { while(!Q.empty() &amp;amp;&amp;amp; ar[Q.top().second] != Q.top().first) { Q.pop(); } cout &amp;lt;&amp;lt; Q.top().second + 1&amp;lt;&amp;lt; &quot;\\n&quot;; } }}" }, { "title": "[BOJ] 14427 수열과 쿼리 15", "url": "/posts/boj-14427/", "categories": "BOJ", "tags": "BOJ, PS, 수열과 쿼리, 평방 분할", "date": "2021-10-17 10:52:11 +0900", "snippet": "문제 요약 및 풀이14427번: 수열과 쿼리 15다른 풀이 보러가기(풀고 나서, 더 생각하니 이 풀이는 너무나 닭 잡는데 소칼을 쓴 격이 되었다. )오랜만에 세그먼트 트리를 복습하고자 본 문제였지만, 결국 제일 좋아하는 알고리즘이 된(?!) sqrt decomposition을 이용해 풀게 되었다.sqrt decomposition은 되게 어려워보이지만, 정말 간단한 아이디어로 어려운 상황을 해결할 수 있게 해준다.먼저 문제를 요약해보자.최대 길이가 10만인 수열 A가 주어지고 최대 10만인 M개의 쿼리에 대해서 수행해야 한다.주어지는 쿼리는 아래 2개다.1. i번쨰에 있는 숫자를 v로 변경해라.2. 전체 수열의 최솟값의 인덱스를 출력하라.한번 모든 쿼리를 나이브하게 처리한다고 생각해보자.10만개의 숫자 중 최솟값을 최대 10만번 알아내야 하기 때문에, 10만 x 10만으로 100억이 된다. 무조건 시간초과가 뜬다.(질문 목록을 보니 예전에는 나이브하게 풀리는 허점이 있었던 것 같긴 하다. 테케 추가되었으니 안 될듯?)그럼 여기에 sqrt decomposition 아이디어를 접목해보자.평방 분할의 큰 아이디어는 여러 값들의 대표값을 sqrt(N)개 만큼 뽑아놓고 그값들을 갱신하고, 활용하자 라고 할 수 있다.N개의 값이 있고, \\(\\sqrt N\\) 개만큼을 묶어서, \\(\\sqrt N\\) 개 만큼의 대표값을 만든다.여기서 대표값은 \\(\\sqrt N\\) 개 수의 최소값 및 최소값의 인덱스일 것이다.한번 쿼리를 처리해보자.1번 쿼리를 복잡하게 생각할 필요없이 그냥 \\(\\sqrt N\\) 개의 숫자를 순회하면서 대표값을 갱신하면 된다.(단, 해당 대표값은 바꿔야 하는 i번째 숫자가 포함된 구간의 대표값을 말하는것이다.)2번 쿼리는 정말 간단하게 모든 구간의 대표값을 순회하면서, 최소값과 최소값을 찾으면 된다.두 쿼리의 시간 복잡도는 \\(\\sqrt N\\) 일 것이고, \\(N * \\sqrt N\\) 는 최대 대략 10만 x 300 정도이고, 3000만은 충분히 1초내에 연산된다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i&amp;lt;n; i++)#define INF (ll)1e11using namespace std;typedef long long ll;ll mo[110000];ll mo_idx[110000];ll ar[110000];ll N, sq, Q, q, a, b;int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N; fill(mo, mo+N, INF); fill(mo_idx, mo_idx+N, -1); for(sq = 0; sq*sq &amp;lt; N; sq++); for1(0, N) { cin &amp;gt;&amp;gt; ar[i]; if(mo[i/sq] &amp;gt; ar[i]) { mo[i/sq] = ar[i]; mo_idx[i/sq] = i; } } cin &amp;gt;&amp;gt; Q; while(Q--) { cin &amp;gt;&amp;gt; q; if (q == 1) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; a--; ar[a] = b; ll partition = a/sq; mo[partition] = INF; mo_idx[partition] = -1; for1(partition * sq, min((partition + 1) * sq, N)) { if(mo[i/sq] &amp;gt; ar[i]) { mo[i/sq] = ar[i]; mo_idx[i/sq] = i; } } } else { ll mn = INF; ll ret = -1; for1(0, sq) { if(mo[i] &amp;lt; mn &amp;amp;&amp;amp; mo_idx[i] != -1) { mn = mo[i]; ret = mo_idx[i]; } } cout &amp;lt;&amp;lt; ret + 1 &amp;lt;&amp;lt; &quot;\\n&quot;; } }}" }, { "title": "[BOJ] 19572 가뭄(small)", "url": "/posts/boj-19572/", "categories": "BOJ", "tags": "BOJ, PS, math", "date": "2021-10-13 19:01:50 +0900", "snippet": "문제 요약 및 풀이19572번: 가뭄(small)연립방정식을 풀자.\\(a + b = d_1\\)\\(a + c = d_2\\)\\(b + c = d_3\\)\\(a - b = y - z\\)\\(a + b = x\\)\\(2 * a = x + y - z\\)\\(a = (x + y - z) / 2\\)\\(b = d_1 - (x + y - z) / 2\\)\\(c = d_2 - (x + y - z) / 2\\)풀이 코드\\(d_1, d_2, d_3\\) 를 각각 \\(x, y, z\\) 로 대체한다.x, y, z=map(int,input().split())a = (x + y - z) /2b = x - ac = y - aif a &amp;lt;= 0 or b &amp;lt;= 0 or c &amp;lt;= 0: print(-1)else: print(1) print(a, b, c)" }, { "title": "[CSSBattle] Target #7 - Leafy Trail", "url": "/posts/css-battle-07/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-10 18:48:02 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #7 - Leafy Trail문제 풀러가기동일한 잎 모양의 도형이 3개 반복된다. box-shadow를 이용해서, 간단하게 처리하자!&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;style&amp;gt; body { background: #0B2429; } i { position: absolute; right: 75px; top: 50%; transform: translateY(-50%); width: 150px; height: 150px; background: #F3AC3C; border-radius: 100px 0 ; box-shadow: -50px 0 0 #998235, -100px 0 0 #1A4341; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Target #6 - Missing Slice", "url": "/posts/css-battle-06/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-10 18:24:41 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #6 - Missing Slice문제 풀러가기이것도 특이한 아이디어는 없다.단순히 구획을 4개로 나누었고, 각각 border-radius를 따로 적용했다.&amp;lt;div&amp;gt; &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; body { background: #E3516E; margin: 0; } div { display: flex; flex-wrap: wrap; width: 200px; position: absolute; transform: translate(-50%, -50%); left: 50%; top: 50%; } i { flex-basis: 50%; height: 100px; background: #111; } i:nth-child(1) { background: #51B5A9; border-radius: 100% 0 0; } i:nth-child(2) { background: #FADE8B; border-radius: 0 100% 0 0; } i:nth-child(3) { background: #F7F3D7; border-radius: 0 0 0 100%; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Target #5 - Acid Rain", "url": "/posts/css-battle-05/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-10 17:48:18 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #5 - Acid Rain문제 풀러가기일단 빗방울 같이 생긴 도형 2개는 box-shadow를 이용해서, 같이 처리하면 될 것 같았다.문제는 오른쪽 원이었고, border-radius가 달랐기에 새로 하나 만들고, 픽셀로 계산해서 조절해서 넣자 생각을 했다.&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; body { background: #0B2429; margin: 0; } div { position: absolute; width: 120px; height: 120px; background: #F3AC3C; } div:nth-child(1) { left: 200px; top: 30px; border-radius: 50%; } div:nth-child(2) { left: 80px; top: 150px; border-radius: 50% 0 50% 50%; box-shadow: 60px -60px 0 0 #998235; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Target #4 - Ups n Downs", "url": "/posts/css-battle-04/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-10 17:35:52 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #4 - Ups n Downs문제 풀러가기보자마자 일단 6개의 구역을 나누고, 짝수번째인것의 색상을 바꾸자 라는 생각부터 들었다.그리고 flex로 각 영역마다 너비를 33%씩 나누어 가지게 만들어서 영역이 아래로 내려가게 하면 되겠지 생각을 해서 쭉 구현을 했다.근데, 정확도가 99.5%가 나왔다.왜인지 한번 슬라이딩을 하면서 자세히 보았더니 33%씩 나누어가졌기 때문에 1% 너비의 오차가 생겼고, 이게 0.5%의 정확도 차이를 발생시켰다. ㅋㅋㅋ일단 33.3%로 바꾸어 해결하였지만, 이 사이트의 문제들이 px단위로 검증하기 때문에 그냥 너비를 100px로 하는게 더 심플한 것 같기도 하다.&amp;lt;section&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/section&amp;gt;&amp;lt;style&amp;gt; body { background: #62306D; margin: 0; } section { display: flex; flex-wrap: wrap; width: 300px; margin: 50 auto 0 auto; } div { height: 100px; flex-basis: 33.3%; } div:nth-child(2n) { background: #F7EC7D; } div:nth-child(2) { border-radius: 50% 50% 0 0; } div:nth-child(4),div:nth-child(6) { border-radius: 0 0 50% 50%; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Target #3 - Push Button", "url": "/posts/css-battle-03/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-10 17:17:52 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #3 - Push Button문제 풀러가기얼핏보면 원을 여러모로 많이 만들어야 하는 풀이로 풀 수도 있다.근데, 원의 모양이 바깥으로 점점 퍼져나가는 걸 보고, box-shadow를 중첩해서 쓰면 될 것 같다는 생각이 들었다.(나는 div를 정가운데로 보낼 때, 자연스럽게 absolute, transform 트릭을 쓴다. 다른 사람의 코드를 찾아보고 더 간결한게 있는지 알아봐야 겠다는 생각이 들었다.)&amp;lt;div id=&quot;a&quot;&amp;gt; &amp;lt;div id=&quot;b&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; body { background: #6592CF; } #a { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 300px; height: 150px; background: #243D83; } #b { background: #EEB850; width: 50px; height: 50px; border-radius: 25px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 0 50px #243D83, 0 0 0 100px #6592CF; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Target #2 - Carrom", "url": "/posts/css-battle-02/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-09 19:02:30 +0900", "snippet": "CSSBattleCSS Battle 사이트는?Target #2 - Carrom문제 풀러가기같은 요소 4개를 만들고, 4방향으로 퍼뜨리면 되는 문제다.일단 아래와 같이 복잡하게 풀었는데.. 조금 더 쉽게 해결되는 방법이 있는지 더 생각해봐야겠다..&amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; body { margin: 0; background: #62374e; } body &amp;gt; div { display: flex; margin: 0 -50px; flex-direction: column; justify-content: space-around; height: 100%; } body &amp;gt; div &amp;gt; div { height: 100%; display: flex; justify-content: space-around; align-items: center; } div &amp;gt; div &amp;gt; div { width: 50px; height: 50px; background: #fdc57b; }&amp;lt;/style&amp;gt;끝" }, { "title": "[CSSBattle] Css Battle 사이트 알아보기 &amp; Target #1", "url": "/posts/css-battle-01/", "categories": "CSSBattle", "tags": "CSSBattle, CSS", "date": "2021-10-09 18:43:22 +0900", "snippet": "CSSBattleonline tutorial 영상을 통해 접한 사이트다.이 사이트에서는 아래와 같이 오른쪽에 주어진 Target을 HTML, CSS로 만들어내는 문제를 풀 수 있다. 또, 서로 경쟁하는 시스템도 있는 것 같다.Target #1 - Simply Square문제 풀러가기body에 있는 기본 margin을 0으로 만들면 쉽게 풀린다.도형의 px 등의 수치는 직접 알아내야 하는 것 같다.Output을 슬라이딩하면 쉽게 정답과 비교할 수 있는 기능이 있어서 그렇게 크게 문제가 되는 것 같지는 않다 :]&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; body { margin: 0; background: #5d3a3a; } div { width: 200px; height: 200px; background: #b5e0ba; }&amp;lt;/style&amp;gt;끝" }, { "title": "[BOJ] 12205 주유소", "url": "/posts/boj-13305/", "categories": "BOJ", "tags": "BOJ, PS, Greedy, KOI 2016 중등부", "date": "2021-10-07 20:49:35 +0900", "snippet": "문제 풀이12205번: 주유소문제를 해결하는 방법은 심플하다.최대한 싼 곳에서 기름을 많이 넣자.그럼, 모든 곳마다 얼마큼 넣어야하는지를 탐색하면서 구해야할까?아니다. 그냥 앞에서부터 뒤에까지 탐색을 하면서, 그 지점까지 오면서 싼 가격이 얼마였는지 기록해놓고 그때그때 가야 하는 거리에 해당 가격을 곱해서 누적해가면 된다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i&amp;lt;n; i++)using namespace std;typedef long long ll;ll N, ans, mn;ll dis[110000];ll cost[110000];int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N; for1(1, N) cin &amp;gt;&amp;gt; dis[i]; for1(0, N) cin &amp;gt;&amp;gt; cost[i]; mn = cost[0]; for1(1, N) { ans += dis[i] * mn; mn = min(mn, cost[i]); } cout &amp;lt;&amp;lt; ans;}끝" }, { "title": "[BOJ] 2205 저울 추 만들기", "url": "/posts/boj-2205/", "categories": "BOJ", "tags": "BOJ, PS, Greedy", "date": "2021-10-07 20:34:19 +0900", "snippet": "문제 요약 및 풀이2205번: 저울 추 만들기문제를 보자마자, 일단 쭉 나열해봤다.1 21 21 2 33 2 11 2 3 43 2 1 41 2 3 4 51 2 5 4 31 2 3 4 5 61 6 5 4 3 21 2 3 4 5 6 77 6 5 4 3 2 11 2 3 4 5 6 7 87 6 5 4 3 2 1 81 2 3 4 5 6 7 8 91 6 5 4 3 2 9 8 7나열을 직접 해보면서 규칙성을 찾으려고 했는데, 두 가지를 발견했다. 무조건 2개의 숫자 혹은 같은 숫자끼리 짝 지으면 된다. 가장 큰 수 부터 가능한 가장 가까운 2의 거듭제곱 합을 만들면서 내려오면 된다는 것.말 그대로 그리디하게 쭈욱 최적의 답을 넣으면서 오면 된다는 것이다.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int N;int D[11000];int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N; for(int i = N; i &amp;gt; 0; i--) { if(D[i]) continue; int z = 2; while(true) { if(z &amp;gt; i &amp;amp;&amp;amp; !D[z-i]) { D[i] = z-i; D[z-i] = i; break; } z &amp;lt;&amp;lt;= 1; } } for(int i = 1; i &amp;lt;= N; i++) { cout &amp;lt;&amp;lt; D[i] &amp;lt;&amp;lt; &quot;\\n&quot;; }}끝" }, { "title": "[BOJ] 2212 센서", "url": "/posts/boj-2212/", "categories": "BOJ", "tags": "BOJ, PS, sorting, greedy", "date": "2021-10-03 19:34:43 +0900", "snippet": "문제 요약 및 풀이2212번: 센서처음에 문제 지문을 보고 이해가 안 갔다.아래와 같이 바꿀 수 있지 않을까?## 문제한국도로공사는 고속도로의 유비쿼터스화를 위해 일직선의 고속도로 위에 N개의 센서를 설치하였다.이 센서들로부터 자료를 모으고 분석할 몇 개의 집중국을 세우려 하지만, 예산상의 문제로 고속도로 위에 최대 K개의 집중국을 세울 수 있다.각 집중국은 센서와 통신할 수 있는 영역, 센서 수신 가능 영역 자유롭게 조절할 수 있으며, 수신 가능 영역 길이는 0 이상인 연결된 구간으로 나타낼 수 있다.N개의 센서는 모두 적어도 하나의 집중국과 통신해야 하지만, 집중군의 유지비 문제로 각 집중국의 수신 가능 영역 길이의 합을 최소화해야 한다.## 입력첫째줄에 센서의 개수 N, 둘째줄에 설치할 수 있는 집중국의 개수 K가 주어진다.셋째줄에는 고속도로에 설치된 N개의 센선의 좌표가 한 개의 정수로 주어진다.(단, 좌표의 절대값은 1,000,000 이하이며, 같은 위치에 설치된 센서가 있을 수 있다.)## 출력각 집중국의 수신 가능 영역 거리의 합의 최솟갑을 출력한다.## 예제 입력621 6 9 3 6 7## 예제 출력5## 예제 설명센서가 순서대로 좌표 1, 3, 6, 6, 7, 9에 설치되어있다.[1, 3], [6, 9] 영역을 수신 가능 영역으로 설정한 2개의 집중국을 세우면, 수신 가능 영역 길이의 합이 5로 최소이다.(어떻게 가공을 하려고 해도 문제 설명이 어색한 것 같다;;)이제, 풀이를 살펴보자.센서의 개수가 총 N개이다. 따라서, 센서 사이 구간은 총 N-1개이다.집중국의 개수는 최대 K 개이다. 따라서, 집중국을 세워서 만들 수 있는 구간은 총 K개이다.근데, 다르게 말해서, N-1개의 센서 사이 구간들 중, K-1개의 구간을 삭제할 수 있다는 이야기가 된다.따라서, N-1개의 센서 사이 구간의 길이를 쭉 나열해두고, 정렬해서 최대 K-1개의 구간을 날리고, 길이의 합을 구하면 된다.풀이 코드n = int(input())k = int(input())sensors = sorted(list([*map(int,input().split())]))diffs = sorted([sensors[i] - sensors[i-1] for i in range(1,len(sensors))])print(sum(diffs[:(len(diffs) if k == 1 else 1 - k)]))" }, { "title": "[TIL] vue에서 cytoscape 사용하기 1", "url": "/posts/TIL-cytoscape-vue/", "categories": "TIL", "tags": "Vue.js, cytoscape", "date": "2021-10-03 01:19:23 +0900", "snippet": "계기개인 프로젝트로 connection 이라는 이름의 프로젝트를 진행중이다.해당 프로젝트에서는 특정 아이템들을 그래프화시켜서 보여주어야 하는데, 무슨 라이브러리를 쓸지 고민하다가 cytoscape 를 쓰기로 했다.cytoscape를 쓰기로 결심을 하게 된 가장 큰 이유는 아래 demo였다.demo 보러가기문제는 connection 프로젝트에서 Vue.js를 쓰기로 마음먹었는데, 여기서 어떻게 이걸 쓰냐였다.vue component로 wrapping 해놓은 vue-cytoscape가 있는 것 같긴 했지만..star 수나, issue 수를 보고 사용하고 싶은 마음이 별로 없어졌다.그냥 직접 가져와서 뻘짓 해보기로 결정했다.그럼 어떻게 하지?일단 설치&amp;gt; yarn add cytoscape그리고 직접 import 해서 여러 뻘짓을 했는데, 계속 element가 잘 안보였다.원인을 찾다가 관련 스택오버플로우 답변을 찾았다.일단 그대로 적용했다.&amp;lt;template&amp;gt; &amp;lt;div id=&quot;cy-wrapper&quot;&amp;gt; &amp;lt;div id=&quot;cy&quot; ref=&quot;cyElement&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;import { defineComponent, nextTick, onMounted, ref } from &#39;vue&#39;import cytoscape from &#39;cytoscape&#39;;export default defineComponent({ name: &#39;CytoscapeTest&#39;, setup() { const cyElement = ref(null); const cyInstance = ref(null); const resizeGraph = () =&amp;gt; { if (cyInstance.value) { cyInstance.value.resize(); } } const test = async () =&amp;gt; { await nextTick() resizeGraph(); } onMounted(() =&amp;gt; { import(&#39;cytoscape&#39;) .then((cy) =&amp;gt; { const cytoscape = cy.default; }) .then(() =&amp;gt; { const element = document.createElement(&#39;div&#39;); element.setAttribute(&#39;id&#39;, &#39;cy-mounting-point&#39;); cyElement.value.appendChild(element); cyInstance.value = Object.freeze( cytoscape({ container: element, elements: [ // list of graph elements to start with { // node a data: { id: &#39;a&#39; } }, { // node b data: { id: &#39;b&#39; } }, { // edge ab data: { id: &#39;ab&#39;, source: &#39;a&#39;, target: &#39;b&#39; } } ], style: [ // the stylesheet for the graph { selector: &#39;node&#39;, style: { &#39;background-color&#39;: &#39;#666&#39;, &#39;label&#39;: &#39;data(id)&#39; } }, { selector: &#39;edge&#39;, style: { &#39;width&#39;: 3, &#39;line-color&#39;: &#39;#ccc&#39;, &#39;target-arrow-color&#39;: &#39;#ccc&#39;, &#39;target-arrow-shape&#39;: &#39;triangle&#39;, &#39;curve-style&#39;: &#39;bezier&#39; } } ], layout: { name: &#39;grid&#39;, rows: 1 } }) ); test(); }) }); return { cyElement, } },})&amp;lt;/script&amp;gt;하지만 여전히 보이지 않았다.근데, 아래 이미지와 같이 canvas element는 있는데 보이지 않았고, 어? width, height 문제인가? 라는 생각이 들었다.그래서 아래 코드와 같이 임시로 스타일을 추가해주었더니, 아주 잘 보였다..(왠지 나의 뻘짓 코드도 동일한 문제였던 것 같고, stackoverflow의 코드처럼 복잡한 코드가 되지 않아도 되지 않았을까 라는 생각이 들었다.. 일단 다음에 고치기로 했다..)&amp;lt;style lang=&quot;scss&quot;&amp;gt;#cy { width: 100%; min-height: 1000px; div { width: 100%; min-height: 1000px; } div#cy-mounting-point { canvas { padding-left: 0; padding-right: 0; margin-left: auto; margin-right: auto; display: block; } }}&amp;lt;/style&amp;gt;일단 그래프 형태로 찍어냈다는 것에 만족하고… 원하는 형태의 그래프로 조금씩 바꾸어 나가면 될 것 같다.끝" }, { "title": "[기초 PS 지식] 두 원의 교차 여부 판단하기", "url": "/posts/detect-intersection-two-circle/", "categories": "basic", "tags": "math, ps", "date": "2021-10-01 23:10:49 +0900", "snippet": "문제 상황두 원의 x, y 좌표가 주어지고, 각각 반지름이 주어졌다고 하자.이때, 두 원이 겹쳐진 부분이 있는지 판단하자.기본 지식한번 아래 그림들을 쭉 보면서, A점과 B점 사이의 거리에 집중해보자.두 원이 겹쳐져 있을 때두 원이 겹쳐져 있을 때, A점과 B점사이의 거리는 두 원의 반지름의 합(r1 + r2)보다 짧다.두 원이 접할 때두 원이 겹쳐져 있을 때, A점과 B점사이의 거리는 두 원의 반지름의 합(r1 + r2)과 같다.두 원이 떨어져 있을 때두 원이 겹쳐져 있을 때, A점과 B점사이의 거리는 두 원의 반지름의 합(r1 + r2)보다 길다.코드로 나타내기그럼 이걸 코드로 나타내자.예시로 만약 두 원이 겹친다면 YES를, 접하거나 떨어져 있는 경우 NO를 출력하는 코드를 작성해보자.(22938번: 백발백준하는 명사수의 상황이다.)x1, y1, r1 = map(int, input().split())x2, y2, r2 = map(int, input().split())print(&quot;YES&quot; if ((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2)) ** (1/2) &amp;lt; r+r2 else &quot;NO&quot;)위와 같이 직관적으로 점과 직선사이의 공식을 써서 해결할 수 있다. 심지어, 저 위 링크의 문제도 이 코드로 해결된다.다만, 가끔 소수점 연산의 오차를 노린 테케가 섞여 있는 문제가 있을 수도 있으니이럴 때 루트(sqrt)를 적용한 코드보단, 아래와 같이 양변을 제곱해 소수점 연산을 안하는 것이 더 좋다.x1, y1, r1 = map(int, input().split())x2, y2, r2 = map(int, input().split())print(&quot;YES&quot; if (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2) &amp;lt; r*r + r2*r2 + 2*r*r2 else &quot;NO&quot;)끝" }, { "title": "[TIL] python으로 숏코딩 하기 1", "url": "/posts/TIL-python-short-coding-1/", "categories": "TIL", "tags": "python, short coding", "date": "2021-10-01 21:34:20 +0900", "snippet": "n을 입력받고 n번 반복문 돌리기22155번: Простая задача 문제를 풀고, 숏코딩 풀이들을 살펴보다 알게 되었다.주어진 상황을 직관적으로 짜보면 아래와 같다.n = int(input())for i in range(n):하지만 뒤 코드에 n을 활용하지 않는다면, 아래와 같이 range에 포함시킬 수 있다.for i in range(int(input())):이게 끝이 아니다.for i in &#39; &#39;*int(input()):어차피 n번 반복하면 되기 때문에 n이 크지 않다면 무난하게 위와 같이 짧게 쓸 수 있다.(clean code라고 할 수 있을 지는 모르겠지만 재밌다.)" }, { "title": "[BOJ] 3878 점 분리", "url": "/posts/boj-3878/", "categories": "BOJ", "tags": "BOJ, PS, Convex Hull", "date": "2021-09-30 23:34:26 +0900", "snippet": "문제 요약 및 풀이3878번: 점 분리사실 1년 전에 푼 문제다.기하 알고리즘을 갑자기 한번 쓰윽 볼까? 하고 다시 핀 문제인데,1년동안 회사일을 하면서 다 까먹었음을 느꼈다. 컨벡스헐의 ㅋ 자도 못 구현하고 있었다.그래서, 그냥 1년 전의 나의 코드를 가져와서 코드를 리팩토링하면서, 다시 공부했다.풀이 설명은 코드에 주석으로 담았다.(또 다른 미래의 나를 위해)풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i&amp;lt;n; i++)#define for1j(s,n) for(int j = s; j&amp;lt;n; j++)#define foreach(k) for(auto i : k)#define foreachj(k) for(auto j : k)#define pb(a) push_back((a))#define sz(a) a.size()using namespace std;typedef unsigned long long ull;typedef long long ll;typedef vector &amp;lt;int&amp;gt; iv1;typedef vector &amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; iv2;typedef vector &amp;lt;ll&amp;gt; llv1;typedef unsigned int uint;typedef vector &amp;lt;ull&amp;gt; ullv1;typedef vector &amp;lt;vector &amp;lt;ull&amp;gt; &amp;gt; ullv2;struct point{ ll x, y, p=0, q=0; bool operator &amp;lt;(point b){ if(x != b.x) { return x &amp;lt; b.x; } return y &amp;lt; b.y; }; bool operator ==(point b) { return y == b.y &amp;amp;&amp;amp; x == b.x; } bool operator &amp;lt;=(point b){ if(y == b.y &amp;amp;&amp;amp; x == b.x) return true; if(x != b.x) { return x &amp;lt;= b.x; } return y &amp;lt;= b.y; };};ll N, M, tc;vector &amp;lt;point&amp;gt; black;vector &amp;lt;point&amp;gt; white;ll ccw(point p1, point p2, point p3) { ll ret = 1ll * (p1.x * p2.y + p2.x * p3.y + p3.x * p1.y - p2.x * p1.y - p3.x * p2.y - p1.x * p3.y); return ret &amp;gt; 0 ? 1 : (ret &amp;lt; 0 ? -1 : 0);}bool comp(point a, point b) { if(a.q * b.p != a.p*b.q) return 1ll * a.q * b.p &amp;lt; a.p * b.q; if(a.y != b.y) return a.y &amp;lt; b.y; return a.x &amp;lt; b.x;}void swapPoint(point a, point b) { point tmp; tmp = a; a = b; b= tmp;}vector &amp;lt;int&amp;gt; getConvexHull(vector &amp;lt;point&amp;gt;&amp;amp; points) { vector &amp;lt;int&amp;gt; stk; stk.clear(); // y 좌표, x 좌표가 작은 순으로 정렬 sort(points.begin(), points.end(), comp); // 0번째 점을 기준으로 상대 위치 계산 for(int x=1; x&amp;lt;points.size(); x++) { points[x].p = points[x].x - points[0].x; points[x].q = points[x].y - points[0].y; } // 문제 특성상, 두 컨벡스 헐이 겹치는지 판단해야 하므로, 같은 점을 2번 반환한다. if(points.size() == 1) { return {0, 0}; } // 0번째 점을 제외하고, 반시계 방향으로 정렬(0번째 점을 기준으로 한 상대 위치로 하여금) sort(points.begin() + 1, points.end(), comp); stk.push_back(0); stk.push_back(1); for(int next = 2; next &amp;lt; points.size(); next++) { // 현재 stack에 쌓인 점이 2개 이상일 때, while(stk.size() &amp;gt;= 2) { int second = stk.back(); stk.pop_back(); int first = stk.back(); if(ccw(points[first], points[second], points[next]) &amp;gt; 0) { // 이전 점 2개와 비교했을 때, 반시계 방향을 향할 때(좌회전), 다시 second를 넣어준다. stk.push_back(second); break; } } stk.push_back(next); } // 컨벡스 헐에 담긴 점들의 idx가 return 된다. return stk;}bool is_intersected_line(point a, point b, point c, point d) { ll line_a_b = ccw(a, b, c) * ccw(a, b, d); ll line_c_d = ccw(c, d, a) * ccw(c, d, b); if(line_a_b == 0 &amp;amp;&amp;amp; line_c_d == 0) { if(b &amp;lt; a) swapPoint(a, b); if(d &amp;lt; c) swapPoint(c, d); return (c &amp;lt;= b &amp;amp;&amp;amp; a &amp;lt;= d); } return line_a_b &amp;lt;= 0 &amp;amp;&amp;amp; line_c_d &amp;lt;= 0;}void init() { ll x, y; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; black.clear(); white.clear(); for1(0, N) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; black.push_back({ x, y, 0, 0}); } for1(0, M) { cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; white.push_back({x, y, 0, 0}); }}int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; tc; while(tc--) { init(); if(N==1 &amp;amp;&amp;amp; M ==1) { /* 각각 점이 한 개씩 있는 경우, 두 그룹으로 나눌 수 있다. */ cout &amp;lt;&amp;lt;&quot;YES\\n&quot;; continue; } vector &amp;lt;int&amp;gt; black_covex_hull = getConvexHull(black); vector &amp;lt;int&amp;gt; white_convex_hull = getConvexHull(white); bool invalid = false; int black_size = black_covex_hull.size(); int white_size = white_convex_hull.size(); // convex hull의 각 선분별로 서로 겹치는지 검사한다. for1(0, black_size) { for1j(0, white_size) { point a,b,c,d; a = black[black_covex_hull[i]]; b = black[black_covex_hull[(i+1) % black_size]]; c = white[white_convex_hull[j]]; d = white[white_convex_hull[(j+1) % white_size]]; if(is_intersected_line(a, b, c, d)) { invalid = true; break; } } if(invalid) break; } /* 아래 경우는 교차하지 않는 두 컨벡스 헐임을 고려해야 한다. */ bool black_convex_hull_include_white_point = true; bool white_convex_hull_include_black_point = true; // white 점이 black convex hull 안에 포함되어 있는지 검사한다. for1(0, black_size) { for1j(0, white_size) { point a, b, c; a = black[black_covex_hull[i]]; b = black[black_covex_hull[(i+1) % black_size]]; c = white[white_convex_hull[j]]; // 하나의 하얀색 점이아도 시계 방향을 향하는 점이라면, // white convex hull이 black convex hull에 포함되지 않는다. if(ccw(a, b, c) &amp;lt;= 0) { black_convex_hull_include_white_point = false; break; } } if(!black_convex_hull_include_white_point) break; } if(black_convex_hull_include_white_point) invalid = true; // black 점이 white convex hull 안에 포함되어 있는지 검사한다. for1(0, white_size) { for1j(0, black_size) { point a, b, c; a = white[white_convex_hull[i]]; b = white[white_convex_hull[(i+1) % white_size]]; c = black[black_covex_hull[j]]; // 하나의 검은색 점이아도 시계 방향을 향하는 점이라면, // black convex hull이 white convex hull에 포함되지 않는다. if(ccw(a, b, c) &amp;lt;= 0) { white_convex_hull_include_black_point = false; break; } } if(!white_convex_hull_include_black_point) break; } if(white_convex_hull_include_black_point) invalid = true; cout &amp;lt;&amp;lt; (invalid ? &quot;NO&quot; : &quot;YES&quot;) &amp;lt;&amp;lt; &quot;\\n&quot;; }}끝" }, { "title": "[BOJ] 22351 수학은 체육과목 입니다 3", "url": "/posts/boj-22351/", "categories": "BOJ", "tags": "BOJ, PS, Bruteforce", "date": "2021-09-29 20:36:22 +0900", "snippet": "문제 요약 및 풀이22351번: 수학은 체육과목 입니다 3시작 지점을 특정하는 방법이 중요하다.시작 지점을 임의의 수로 생각하는게 아니라, 특정 길이의 수로 보고 탐색하면 빠르고, 간단하게 처리할 수 있다.풀이 코드s = input()for start_len in range(1, len(s)+1): s2 = s[:start_len] n = int(s2) while len(s2) &amp;lt; len(s): n += 1 s2 += str(n) if s2 == s: print(s[:start_len], n) break끝" }, { "title": "[BOJ] 1359 복권", "url": "/posts/boj-1359/", "categories": "BOJ", "tags": "BOJ, PS, combination", "date": "2021-09-28 22:49:48 +0900", "snippet": "문제 요약 및 풀이1359번: 복권python itertools에는 너무나 좋은 것이 많다. ㅎㅎ이 문제는 그냥 모든 경우를 탐색해도 된다. 그냥 빠르게 긁어버리자.(N,M이 8보다 작거나 같다. 경우 의 수가 8C4 정도가 최대다. 충분히 다 탐색할 수 있다.)풀이 코드from itertools import combinationsn, m, k = map(int,input().split())ans = 0all = [*combinations([i for i in range(n)], m)] # 모든 경우의 수for i in all: cnt = 0 for j in range(m): if i[j] &amp;lt; m: # 0 ~ m-1이 복권에 당첨되는 번호라고 가정한다. cnt+=1 if cnt &amp;gt;= k: # k 개 이상 맞은 경우 ans += 1print(ans / len(all))끝" }, { "title": "[BOJ] 20443 배드민턴 대회", "url": "/posts/boj-20443/", "categories": "BOJ", "tags": "BOJ, PS, math, 교란순열", "date": "2021-09-28 22:01:18 +0900", "snippet": "문제 요약 및 풀이20443번: 배드민턴 대회문제를 딱 보자 마다, 어디선가 봤던 건데… 하고 망설였는데,결론적으로는 교란순열이었다. (맨날 점화식 까먹는 것 같다.)i) 교란순열의 i번째 항을 d[i]라 하자.ii) 주어진 수가 4의 배수 인 경우, d[i]를 반환한다.iii) 주어진 수가 4의 배수가 아닌 경우, combination(i, i % 4) * d[i - (i % 4)] 를 반환한다.iii)에서는 4의 배수를 맞추기 위해 빠지는 인원을 정하는 경우의 수를 따로 곱한 것이다.풀이 코드MOD = 1_000_000_007derangement = [1, 0, 1, 2, 9]for i in range(5, 110): derangement.append(((i-1) * (derangement[-1] + derangement[-2])) % MOD)def nCr(n, k): ret = 1 for i in range(n, n-k, -1): ret *= i for i in range(1, k+1): ret //= i return retn = int(input())k = n % 4print((derangement[n - k] * nCr(n, k)) % MOD)끝" }, { "title": "[BOJ] 20551 Sort 마스터 배지훈의 후계자", "url": "/posts/boj-20551/", "categories": "BOJ", "tags": "BOJ, PS, binary search", "date": "2021-09-22 16:03:44 +0900", "snippet": "문제 요약 및 풀이20551번: Sort 마스터 배지훈의 후계자이진탐색을 잘 하자.풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i=s; i&amp;lt;n; i++)using namespace std;int N, M, a;int ar[220000];int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for1(0, N) { cin &amp;gt;&amp;gt; ar[i]; } sort(ar, ar+N); for1(0, M) { cin &amp;gt;&amp;gt; a; int *p = lower_bound(ar, ar+N, a); if(p != ar + N &amp;amp;&amp;amp; *p == a) cout &amp;lt;&amp;lt; p - ar; else cout &amp;lt;&amp;lt; -1; cout &amp;lt;&amp;lt; &#39;\\n&#39;; }}끝" }, { "title": "[BOJ] 21966 (중략)", "url": "/posts/boj-21966/", "categories": "BOJ", "tags": "BOJ, PS, 구현", "date": "2021-09-22 15:44:52 +0900", "snippet": "문제 요약 및 풀이21966번: (중략)간단한 구현 문제다.심지어 굉장히 테케가 친절한데,아래 2번째 테케에서 앞/뒤 11글자를 제외한 나머지 부분이 Man. 으로 한 문장안에 포함된다고 한다.따라서, 앞 11글자 / 뒤 12 글자(11글자가 아니다라는 것)를 제외하고 그 안에 . 이 있는 경우, 앞 뒤 내용이 서로 다른 문장에 포함된다는 걸 알려주는 테케다.26And,IamIronMan.IamIronMan.풀이 코드N = int(input())s = input()if len(s) &amp;lt;= 25: print(s)elif &#39;.&#39; in s[11:-12]: print(s[:9]+&#39;.&#39;*6+s[-10:])else: print(s[:11]+&#39;.&#39;*3+s[-11:])끝" }, { "title": "[BOJ] 1503 세 수 고르기", "url": "/posts/boj-1503/", "categories": "BOJ", "tags": "BOJ, PS, Brute force", "date": "2021-09-22 14:39:50 +0900", "snippet": "문제 요약 및 풀이1503번: 세 수 고르기너무 많이 틀려가며 풀었다 ㅠ일단 푸는 방법은 브루트 포스, 다 긁어버리면 된다.하지만 무작정 다 긁으면 TLE 난다.N이 최대 1000이고, 이것보다 조금은 큰 범위로 세제곱만큼해서 긁어야 하는데, 이걸 다 긁으면?가뿐히 1억을 넘긴다.따라서 몇가지 스킵 조건을 걸어서, TLE가 나지 않게 막으면 된다.풀이 코드N, S = map(int,input().split())if S &amp;gt; 0: l = [*map(int,input().split())]else: l = []L = [i for i in range(1,1005) if i not in l]ans = 9876543210for i in L: if i in l or i - N &amp;gt; ans: continue for j in L: if j in l or i*j - N &amp;gt; ans: continue for k in L: if k in l: continue ans = min(ans, abs(N - i*j*k)) if N &amp;lt; i*j*k: breakprint(ans)끝" }, { "title": "[BOJ] 1484 다이어트", "url": "/posts/boj-1484/", "categories": "BOJ", "tags": "BOJ, PS, math", "date": "2021-09-22 14:05:21 +0900", "snippet": "문제 요약 및 풀이1484번: 다이어트일단, 나이브하게 풀었다. ㅋㅋㅋ풀이 코드몇가지 간단한 생각을 하고, 나이브하게 다 긁었다. 특정 수가 제곱인지 확인하는 건, sqrt 씌우고 다시 곱해보면 된다. 어떤 수 i가 순서대로 증가할 때, \\(i*i - (i-1)*(i-1) &amp;gt; g\\) 되는 순간, 더이상 i 를 늘리면서 확인할 필요없다. [중요] 꼭 아무것도 출력 안 한 경우 -1 출력하기.from math import sqrtg = int(input())cnt = 0for i in range(1, 11000000): if i*i - (i-1)*(i-1) &amp;gt; g: break k = i*i + g q = int(sqrt(k)) if k == q*q: print(q) cnt += 1if cnt == 0: print(-1)끝" }, { "title": "[BOJ] 1253 좋다", "url": "/posts/boj-1253/", "categories": "BOJ", "tags": "BOJ, PS, hash", "date": "2021-09-22 13:44:07 +0900", "snippet": "문제 요약 및 풀이1253번: 좋다문제 조건은 심플하다. 어떤 수가 다른 수 2개로 구성되면 이는 좋은 수 이다. 좋은수 a가 있다면, 주어진 수 중 a를 모두 카운트해야 한다.근데, 만약 그냥 단순하게 이중 반복문으로 처리한다면, WA를 신랄하게 맞을거다.d = {} # 각각 요소가 몇개 있는지 저장된 해쉬...ans = 0for i in range(n): for j in range(i+1, n): s = L[i] + L[j] ans += d[s] d[s] = 0왜?아래같은 케이스가 있다.(이게 큰 도움이 되었다… 테케를 알려준 천사님)예시 161 -1 1 -1 0 0예시 정답 16예시 220 0예시 정답 20예시 331 -1 0예시 정답 31풀이 코드그래서 d, d2로 중복되게 해쉬를 만들었고(그냥 NGD로..)두 개의 숫자를 가져와서 더한 결과가 두 대의 숫자에 포함되고, 이게 유일한 경우라면 넘기는 케이스를 추가했다.n = int(input())L = [*map(int,input().split())]d = {}d2 = {}ans = 0for i in L: try: d[i] += 1 d2[i] += 1 except: d[i] = 1 d2[i] = 1for i in range(n): for j in range(i+1, n): s = L[i] + L[j] try: if (s == L[i] and d2[L[i]] == 1) or (s == L[j] and d2[L[j]] == 1) or (s == L[i] == L[j] and d2[L[i]] == 2): continue ans += d[s] d[s] = 0 except: continueprint(ans)" }, { "title": "[BOJ] 1083 소트", "url": "/posts/boj-1083/", "categories": "BOJ", "tags": "BOJ, PS, Greedy", "date": "2021-09-22 01:20:25 +0900", "snippet": "문제 요약 및 풀이1083번: 소트 처음에 어? 그냥 앞에서부터 버블 소트처럼 하면 되는거 아니야?라는 단순한 생각을 했고, 그냥 제출했는데 바로 WA를 받았다.골드가 그렇게 간단하지는 않죠? (ㅋㅋㅋ)바로 떠오른 반례는 이거다51 2 3 4 54앞서 말한 풀이로는 2 3 4 5 1이 나오는데, 사실 답은 5 1 2 3 4 이다.이 반례를 보면서 생각이 났다.1. 아무튼 일단 앞에서부터 가장 큰 숫자를 채워넣야 한다.2. 근데, 정해진 코스트가 있다.3. 그럼? 정해진 코스트 내에서 가져올 수 있는 가장 큰 숫자를 가져오고 대체하자.4. 이걸 앞에서부터 차례대로 하면 되겠지?이 아이디어를 그대로 코드로 바꿨다. 그리고 AC풀이 코드n = int(input())L = [*map(int, input().split())]s = int(input())cur_idx = 0while s &amp;gt; 0 and cur_idx &amp;lt; n: cur_item = L[cur_idx] max_item_idx = cur_idx max_item = L[cur_idx] for i in range(cur_idx, min(cur_idx + s + 1, n)): if cur_item &amp;lt; L[i] and max_item &amp;lt; L[i]: max_item = L[i] max_item_idx = i cost = max(0, max_item_idx - cur_idx) if cost &amp;lt;= s: if cur_idx != max_item_idx: s -= cost L = L[:(cur_idx)] + [L[max_item_idx]] + L[cur_idx:max_item_idx] + L[(max_item_idx+1):] cur_idx += 1print(*L)끝" }, { "title": "[BOJ] 16194 카드 구매하기 2", "url": "/posts/boj-16194/", "categories": "BOJ", "tags": "BOJ, PS, DP", "date": "2021-09-22 00:38:04 +0900", "snippet": "문제 요약 및 풀이16194번: 카드 구매하기 2간단한 DP 문제다.\\[d[i] = 카드 i 개를 갖기 위해 지물해야 하는 금액의 최솟값\\]위와 같이 dp 배열을 정의하고 생각하면 당연하게도 아래와 같은 점화식이 성립한다.for j in range(i) d[i] = min(d[i], d[i - j] + d[j])풀이 코드INF = 123456789n = int(input())l = [0, *map(int,input().split())]d = [INF for _ in range(n + 1)]for i in range(n+1): d[i] = l[i] for j in range(i): d[i] = min(d[i], d[i-j] + d[j])print(d[n])끝" }, { "title": "[BOJ] 1260 DFS와 BFS", "url": "/posts/boj-1260/", "categories": "BOJ", "tags": "BOJ, PS, DFS, BFS", "date": "2021-09-22 00:27:52 +0900", "snippet": "문제 요약 및 풀이1260번: DFS와 BFS크게 따로 설명할 건 없다.DFS와 BFS를 구현하면 된다.(번외로, DFS와 BFS는 최대한 깔끔하게 구현하는 자기만의 코드가 있으면 좋은 것 같다.)풀이 코드#include &amp;lt;bits/stdc++.h&amp;gt;#define for1(s,n) for(int i = s; i&amp;lt;n; i++)#define pb(a) push_back(a)using namespace std;int N, M, V;vector&amp;lt;int&amp;gt; adj[1100];bool check[1100];int a, b;void dfs(int crt) { cout &amp;lt;&amp;lt; crt &amp;lt;&amp;lt; &#39; &#39;; if(!check[crt]) { check[crt] = 1; for(auto i: adj[crt]) { if(!check[i]) { dfs(i); } } }}int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M &amp;gt;&amp;gt; V; for1(0, M) { cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; adj[a].pb(b); adj[b].pb(a); } for1(1, N+1) sort(adj[i].begin(), adj[i].end()); dfs(V); cout &amp;lt;&amp;lt; &#39;\\n&#39;; fill(check, check+1100, false); queue &amp;lt;int&amp;gt; Q; Q.push(V); while(!Q.empty()) { int crt = Q.front(); Q.pop(); if(!check[crt]) { cout &amp;lt;&amp;lt; crt &amp;lt;&amp;lt; &#39; &#39;; check[crt] = 1; for(auto i: adj[crt]) { if(!check[i]) { Q.push(i); } } } }}끝" }, { "title": "[BOJ] 1342 행운의 문자열", "url": "/posts/boj-1342/", "categories": "BOJ", "tags": "BOJ, PS, next_permutation", "date": "2021-09-21 23:55:25 +0900", "snippet": "문제 요약 및 풀이1342번: 행운의 문자열문제 상에 주어지는 문자열의 길이는 최대 10이다.한 문자열이 행운의 문자열인지 판단하기 위해 쭉 훑는 방법은 \\(O(n), (n &amp;lt;= 10)\\) 이다.근데, 주어진 문자열로 만들 수 있는 모든 문자열을 나이브하게 해도 \\(n!\\) 이고, 최대 10!인데,이는 \\(3,628,800\\) 밖에 되지 않는다.따라서 모든 문자열을 다 훑고 판단해도 \\(36,288,000\\) 이기에 바로 구현하면 된다.이때 모든 문자열을 훑는 방법은 다양하지만 c++ algorithm 헤더에 있는 next_permutation을 활용하면 편하다.(next_permutation 함수는 어떤 케이스를 돌리느냐에 따라 시간이 달라질 수 도 있다… 잘 거르고 선택하자.) 참고링크풀이 코드next_permutation을 활용할 때는 2가지를 조심해야 한다. 모든 경우를 탐색하고자 한다면, 정렬을 하고 활용해야 한다. next_permutation을 하고 나서, 바로 다음 경우의 수가 나오는 것이기에 맨 처음 경우의 수를 따로 확인을 하든지, 혹은 do-while 문을 활용하면 편하다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;string s;int ans;bool is_lucky_string() { char last = 0; for(auto i: s) { if(i == last) return false; last = i; } return true;}int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); cin &amp;gt;&amp;gt; s; sort(s.begin(), s.end()); do { if(is_lucky_string()) ans++; } while(next_permutation(s.begin(), s.end())); cout &amp;lt;&amp;lt; ans;}끝" }, { "title": "[BOJ] 17598 Animal King Election", "url": "/posts/boj-17598/", "categories": "BOJ", "tags": "BOJ, PS, 숏코딩", "date": "2021-09-21 00:00:00 +0900", "snippet": "문제 요약 및 풀이 문제는 브론즈라서, 어려운 것은 아니었다. 그냥, 숏코딩이 잘된 문제라 풀이를 남긴다.문제는 심플하다.2명의 후보에게 9명의 유권자가 투표를 한다. 기권표는 없을 때, 누가 당선되는지를 출력하면 된다.물론, 하나하나 표를 카운트하고 더 많이 표를 받은 동물(후보)를 도출해도 된다.하지만 주어진 투표 내용을 sort하고 5번째 요소를 출력하면 그게 바로 당선된 동물(후보)이다.카운팅할 필요가 없다.요걸 알면, 아래와 같이 심플하게 나온다.풀이 코드print(sorted([input()for _ in range(9)])[4])끝" }, { "title": "[TIL - Python] Spread operator", "url": "/posts/python-spread-operator/", "categories": "Python", "tags": "Python, 숏코딩, TIL", "date": "2021-09-21 00:00:00 +0900", "snippet": "Spread operator스프레드 연산자는 배열, 문자열, 객체 등의 Iterable 객체를 개별 요소로 분리해주는 연산자를 말합니다.주로 JS에서 ... 을 쓰면서 한번씩 보게 되는데, Python에서도 있고, 활용할 수 있다는걸 이제서야 알게 되었습니다. (ㅋㅋㅋ)일단 아래와 같이 활용했습니다.한 줄에 공백을 구분으로 숫자 여러개 입력을 받을 때주로 이렇게 입력을 받아왔습니다.L = list(map(int, input().split()))근데, 스프레드 연산자를 쓰면?L = [*map(int, input().split())]리스트 깔끔하게 출력하기아래와 같이 리스트가 있습니다.L = [1, 4, 12, 123]위 리스트를 아래와 같이 출력하려고 합니다. 어떻게 할 수 있을까요?1 4 12 123일단 나이브하게 해봅시다for i in L: print(i, end = &#39; &#39;)이건 너무 길죠? 한번 문자열의 join 메서드를 활용해볼까요?print(&#39; &#39;.join(L))이것도 너무 불편합니다. 이제 스프레드 연산자를 써봅시다.print(*L)정말 간결합니다.스프레드 연산자를 너무 늦게 알아서 정말 불편하게 코드를 짜고 있었네요.하나하나 더 파이썬스럽게 코드를 짤 수 있게 더 알아봐야 할 것 같습니다.끝" }, { "title": "[BOJ] 8989 시계", "url": "/posts/boj-8989/", "categories": "BOJ", "tags": "BOJ, 시계, PS", "date": "2021-09-20 00:00:00 +0900", "snippet": "문제 요약 및 풀이8989번: 시계되게 간단한 실버 문제. 각 시각에 따른 시침, 분침의 각도를 알아낸다. 사이각을 구한다(이때 각도가 2개다. 따라서 이 중에서 최소를 선택한다.) 이 사이각에 따라 정렬하고, 답을 도출한다.풀이 코드for i in range(int(input())): L = input().split() # 입력 D = [] # 정렬을 위한 리스트 for t in L: h,m = map(int, t.split(&#39;:&#39;)) # h: 시간, m: 분 a = ((h % 12) * 30 + m / 2) % 360 # 시침의 각도 b = m * 6 # 분침의 각도 deg = max(a,b) - min(a,b) # 시침과 분침의 각도 D.append([min(deg, 360-deg), i]) # 360 - deg 는 반대각 # 사이각이 같으면 시간이 빠른 순으로 정렬해야 하기 때문에, (각도, 시각) 순으로 아이템을 만든다. D.sort() # 정렬한다. print(D[2][1]) # 결과 출력끝" }, { "title": "[BOJ] 20949 효정과 새 모니터", "url": "/posts/boj-20949/", "categories": "BOJ", "tags": "BOJ, 정렬, PS", "date": "2021-09-20 00:00:00 +0900", "snippet": "문제 요약 및 풀이20949번: 효정과 새 모니터sqrt를 하든 안하든, 문제 상에 주어지는 77인치로 나누든 안 나누든\\(w*w + h*h\\) 의 대소만 비교해서 정렬하면 된다.풀이 코드L = []for i in range(int(input())): w,h = map(int, input().split()) L.append([w*w+h*h, i])for i in sorted(L, key = lambda t : (-t[0], t[1])): print(i[1] + 1)" }, { "title": "[TIL] swiper.js 사용하기", "url": "/posts/TIL-swiper-js/", "categories": "TIL", "tags": "슬라이드쇼, swiper.js", "date": "2020-11-12 00:00:00 +0900", "snippet": "shinkeonkim.github.io/css-animation-study/css animation study이 페이지를 꾸미고 싶었다.뭔가 지금까지 공부하고 있는 내용들을 슬라이드쇼로 보여주고 싶었고,직접 구현하면 재밌겠지만 굳이? 내가 해야하나 싶어서 예전에 썼던 slick.js를 쓸까 하다가뭔가 마음에 안들었던 부분들이 있었어서 새로운 걸 써보자 하고 다른 걸 찾아봤다.그래서 나온 것이 swiper.js 이다.swiperjs.com/demos/Swiper Demos swiperjs.com일단, 굳이 코드를 다운받고 코드를 실행시키고 싶지않다! CDN을 쓰겠다 하면 아래와 같이 css와 script를 가져오면 되고, &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/swiper/swiper-bundle.min.css&quot;&amp;gt;&amp;lt;script src=&quot;https://unpkg.com/swiper/swiper-bundle.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;아래와 같이 swiper를 초기화 하면된다.&amp;lt;div class=&quot;swiper-container&quot;&amp;gt; &amp;lt;div class=&quot;swiper-wrapper&quot;&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 5&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 6&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 7&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 8&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 9&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;swiper-slide&quot;&amp;gt;Slide 10&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; var swiper = new Swiper(&#39;.swiper-container&#39;);&amp;lt;/script&amp;gt;또한, 추가적인 설정을 하는 방법이나 기타 자세한 내용은 그냥 Demo에 들어가서 코드들을 보면 바로 확인할 수 있으니 굳이 남기지 않겠다. 그냥 Demo를 보면서 원하는 효과를 막막 섞어서 넣자. 그러면 어떻게든 만들어진다.만약, Auto Play를 원한다? 그러면 아래 부분을 보면 되는 것처럼..swiperjs.com/demos/#autoplaySwiper Demos swiperjs.com" }, { "title": "[BOJ] silver 문자열 문제 풀이(1)", "url": "/posts/BOJ-prefix-array/", "categories": "algorithm", "tags": "BOJ, prefix array", "date": "2020-02-23 00:00:00 +0900", "snippet": " 원래 prefix array tag를 가진 문제들이었지만, 많이 달라졌네요 ㅋㅋㅋ. 문자열 문제 풀이로 변경하였습니다.BOJ 1639: 행운의 티켓1639번: 행운의 티켓ans = 0L = list(map(int,list(input())))for i in range(len(L)): for j in range(i+1,len(L),2): sub = L[i:j+1] if sum(sub[:len(sub)//2]) == sum(sub[len(sub)//2:]): if ans &amp;lt; len(sub): ans = len(sub)print(ans)BOJ 10751: COW10751번: COW이 문제는 원어 문제인데 대충 (못 미더운 영어실력으로) 해석을 해보면,‘C’, ‘O’, ‘W’ 로 이루어진 문자열 s가 있을 때, 문자열s를 나눈 뒤에 앞에서부터 조합해 만들수있는 “COW”의 개수를 구해라정도로 추릴 수 있습니다.제 풀이는 prefix array를 활용하면서도, 안한 느낌이 납니다만.. 아무튼 설명을 해보자면,0. cnt0 = cnt1 = cnt2 = 01. 문자열을 앞에서부터 탐색한다.2. 현재 문자가 C라면 cnt0에 1 더한다.3. 현재 문자가 O라면 cnt1에 cnt0값만큼 더한다.4. 현재 문자가 W라면 cnt2에 cnt1값만큼 더한다.이 위의 방식대로 한번 문제를 적어보면서 생각해보시면 제가 어떤 방식을 활용했는지 이해되실겁니다. 아마?코드는 아래와같습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;typedef long long ll;int N;string s;ll cnt[3];int main() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; s; for(int x=0; x&amp;lt;N; x++) { if(s[x]==&#39;C&#39;) cnt[0]++; else if(s[x]==&#39;O&#39;) cnt[1]+=cnt[0]; else cnt[2]+=cnt[1]; } cout&amp;lt;&amp;lt;cnt[2];}BOJ 2559: 수열2559번: 수열이 문제는 딱히 따로 문제에 대해서 크게 설명할 필요는 없을 것 같습니다.제가 이 문제를 해결한 방법은 아래와 같습니다. 먼저, 맨 앞에서부터 길이 K를 가지는 부분 배열의 합을 구하고 이를 초기값으로 둡니다. 이제 쭉 뒤로 탐색을 하면서, 기존값에서 앞에 1칸값은 빼고 뒤에 1칸값은 더해가면서 길이 K를 맞춰가며 수치를 구합니다. 그리고 구한 수치들 중 최대값을 찾습니다.  무난무난하게 해결할 수 있는 문제입니다.코드는 다음과 같습니다.N,K=map(int,input().split())L = list(map(int,input().split()))S = 0for i in range(K): S += L[i]ans = Sfor i in range(0,N-K): S-=L[i] S+=L[i+K] if ans &amp;lt; S: ans = Sprint(ans)BOJ 8933: MCS8933번: MCS개인적으로 조금 귀찮았던 문제입니다.사실상 문제 풀이 아이디어나 구현 방식은 실버가 맞는데 조금 들어가는 아이디어가 많았습니다.일단 먼저 코드부터 올려놓겠습니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;typedef long long ll;int T;int N;string s;int cnt[4];void add(int* cnt, char x) { if(x==&#39;A&#39;) cnt[0]++; if(x==&#39;T&#39;) cnt[1]++; if(x==&#39;G&#39;) cnt[2]++; if(x==&#39;C&#39;) cnt[3]++;}void sub(int* cnt, char x) { if(x==&#39;A&#39;) cnt[0]--; if(x==&#39;T&#39;) cnt[1]--; if(x==&#39;G&#39;) cnt[2]--; if(x==&#39;C&#39;) cnt[3]--;}int hash_num(int* cnt) { int ret = 0; for(int x=0; x&amp;lt;4; x++) { ret*=600; ret+=cnt[x]; } return ret;}int main() { cin &amp;gt;&amp;gt; T; while(T--) { for(int x=0;x&amp;lt;4; x++) cnt[x]=0; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; s; if(N&amp;gt;s.length()) { cout &amp;lt;&amp;lt; 0; continue; } map&amp;lt;ll,int&amp;gt; num_cnt; int answer = 0; for(int x=0; x&amp;lt;N; x++) { add(cnt,s[x]); } ll K = hash_num(cnt); if(num_cnt.find(K) !=num_cnt.end()) { num_cnt[K]++; } else { num_cnt[K]=1; } for(int x=0; x&amp;lt;=s.length()-N; x++) { sub(cnt,s[x]); add(cnt,s[x+N]); ll K = hash_num(cnt); if(num_cnt.find(K) !=num_cnt.end()) { num_cnt[K]++; } else { num_cnt[K]=1; } } for(auto it = num_cnt.begin(); it!=num_cnt.end(); it++) { if(answer &amp;lt; it-&amp;gt;second) { answer = it-&amp;gt;second; } } cout&amp;lt;&amp;lt;answer&amp;lt;&amp;lt;&quot;\\n&quot;; }}전 조금 이런저런 고생을 하면서 코드를 작성했는데,add나 sub 함수는 방금 전에 설명한 2559: 수열 문제에서 사용한 아이디어를 활용한 함수입니다.그리고 hash_num 이라는 함수가 있는데, 현재 탐색중인 구간에 A,T,G,C의 개수를 cnt에 저장하게 했고,이 cnt의 상태를 하나의 hash값으로 바꾸어주는 함수입니다.그럼 cnt가 하나의 long long 범위 내에 드는 숫자로 됐으니, 이제 이 hash값을 map을 이용해 key는 hash값, value는 개수로 해서 저장합니다.그리고 맨 마지막에 map을 순회하면서 value 중 최대값이 무엇인지 찾고 출력합니다.조금 복잡하게 짠 느낌이 없지않아 있지만 아무튼 이 정도로 설명할 수 있을 것 같네요.처음으로 문제 풀이를 올리는지라 너무 설명이 번잡하네요. :(끝!" }, { "title": "Good Bye 2019, Hello 2020!", "url": "/posts/goodbye-2019/", "categories": "myStory", "tags": "kmu, 회고, 새내기, 19학번", "date": "2020-01-01 00:00:00 +0900", "snippet": "Good Bye 2019, Hello 2020!국민대 새내기의 뒤늦은 2019 회고벌써 2020년이지만, 2019년을 회상하며 회고를 남겨봅니다.2019년은 특히나 많은 일들이 있었던 것 같아 꼭 남겨보려고 합니다ㅎㅎ제 기억에 남은 큼지막한 일들을 적어보려합니다.첫 번째로 써보는 회고여서 부족한 내용이지만 제가 생각나는 대로 후회, 잘했던 것들을 적어보려 합니다..국민대학교 소프트웨어학부 입학 본인 방금 소프트웨어 특기자 되는 상상함 를 참고하면 될 것 같습니다.사실 저 post의 제목과 달리 저는 국민대학교 소프트웨어 특기자 전형으로 입학을 했고 특기자 전형이라는 이유로 장학금을 받으며 학교를 다니고 있습니다. (장학금 안 끊길려고 공부 또 공부한건 안 비밀)아무튼 저 post에 있는 내용처럼 국민대학교에 입학해서 여러 일을 겪고 여러 학문을 공부했습니다.국민대학교 두리톤(해커톤) 장려상저의 첫 해커톤이었습니다. @==(^^)@해커톤의 주제는 스트레스, 여행, 아이 중 택 1이었습니다.먼저, 기획자들이 자신들이 생각해온 주제를 발표하고 그 주제에 개발자들이 붙어서 하루동안 개발하는 순서로 진행되었습니다.제가 붙은 주제는 아이가 휴대폰을 하면서 횡단보도에서 신호등을 보지않고 건너는 경우를 방지하기 위해 휴대폰의 화면에 신호등 정보를 띄우게 하자! 정도로 요약할 수 있을 것 같습니다.해커톤 코드 깃헙 레포: 링크 아무튼, 첫번쨰 해커톤은 정말 새로웠고 좋은 경험이었습니다.하지만 정말 뼈저리게 저에게 새로운 교훈을 주기도 했습니다.저는 고등학교 때, C,C++,python을 단순히 PS(Problem Solving)를 하는 데만 활용했을 뿐더러 제가 가지고 있던 웹 개발 스택은 HTML,PHP,CSS 가 고작이었습니다.거의 조원들에게 얹혀간 기분이라 굉장히 마음이 힘들었습니다..ㅠㅠ이 해커톤을 발판으로 django, flask, node.js, vue.js를 공부하기 시작했고 현재진행형입니다ㅎㅎ그리고 정말 새벽을 새면서 코드를 짜는 게 생각보다 힘들었습니다.(지금은 뭐 이틀동안 안 자고 코드를 짜기도 합니다..)아래 사진처럼 다같이 커피, 에너지 음료를 마셔가면서 버텼지만 결국 다 전멸을 한 시간대도 있었습니다ㅠㅠ그래도, 우리 기획느님께서 좋은 아이디어를 들고 오고 조원들과 다 같이 기능 구현만을 최대한 구현한 결과 장려상을 수상할 수 있었습니다!첫 ACM-ICPC, 매우 매우 아쉬운 결과대학교 새내기의 2019 ACM-ICPC 후기 링크위의 링크를 참고해주시면 될 것 같습니다!요약하자면, 팀원과의 호흡을 맞추는 시간도 부족했고 나의 실수들이 너무나 크게 작용했다.그리고 전체적으로 문제를 풀 때, 분배를 잘못한 것 같다..(심지어 팀원도 다시 구해야 하는 상황이다..아이고야)학점.. 생각보다 괜찮네?국민대학교에 들어와서 학점에 대해 되게 많이 걱정했다.사실상 특기자를 준비하면서 정시, 수시 모두 준비해서 수학이나 영어에 자신감이 없던 건 아니었지만 다른 학우님들보다 못할까 걱정을 했다.하지만 생각보다 좋은 학점을 받게 되었고 더 열심히 하려고 노력을 했다.(시험 기간 아닐때도, 도서관에서 살았다…!)결국, 1학년 1학기와 1학년 2학기를 통틀어 50학점을 수강하였고 학점 4.4로 1년을 마무리하였다.하계/동계 인턴십, 알고리즘 컨텐츠 제작자위의 부분에서 1학년이 어떻게 50학점을 수강했는지 궁금하신 분이 있을 것이다. 바로 하계/동계 방학에 인턴십을 하였고 하고 있기 때문이다.프로그래머스라는 서비스를 운영하고 있는 그렙(GREPP)이라는 회사에서 알고리즘 컨텐츠 제작자라는 인턴으로 일을 했고 하는 중이다.1학년 1학기에 한번 넣어볼까 했던 이력서가 붙었고, 알고리즘 테스트를 봤는데 생각보다 높은 점수가 나왔고, 어느 순간에 인턴으로 일을 하고 있었다..(?!)인턴으로 일을 하면서 회사 생활을 겪는 것이 좋았고 (물론 돈도 최고..!) 여러 경험을 할 수 있어서 좋은 것 같았다.하지만, 요즘은 살짝 1학년 여름/겨울방학을 못 즐긴다는 생각도 들어 아쉽기도 하다..ㅜㅜ백준, solved.ac 서비스solved.ac라는 백준 온라인 저지 사이트의 문제들의 난이도/알고리즘을 나누고 사용자가 푼 문제의 경험치를 누적하여 랭킹을 나누는 서비스가 있습니다.이 서비스가 언제부터였는지는 잘 모르겠지만, 제가 처음 이 서비스를 발견했을 때는 아직 국민대학교가 화이트리스트에 없던 상황이었습니다.딱, 알고리즘 동아리에서 19학번 동기(형님)께서 화이트리스트 신청을 해주셨고 이 서비스를 이용할 수 있게 됬습니다.이 서비스를 처음 이용하기 시작했을 때는 Gold 티어였습니다.(Gold 몇 티어였는지는 기억이 안나네요.)뭔가 Platinum은 찍어야하지 않을까하면서 Platinum에 포함된 문제를 부리나케 풀기 시작했습니다.그때, 처음으로? 제대로 공부해보게 된 알고리즘이 세그먼트 트리, Mo’s Algorithm인 것 같습니다.현재는 Platinum5이지만 Platinum 4를 향해 달려가고 있습니다. 그리고 열심히 Platinum 1까지 가기를 새해 목표로 잡은 상황입니다.ㅎㅎ새해는 열심히 알고리즘을 공부해보려 합니다. 그래서 아래의 책들을 열심히 읽어보려 합니다! 알고리즘 문제해결전략(종만북), 구종만 지음 Introduction to algorithms, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest,Clifford Stein한아름 서비스, 만들었지만 개편이 필요해2018년 말부터 웹 사이트를 하나 만들기 시작했었다. 바로 본인이 졸업한 한민고등학교의 커뮤니티 사이트이다.한아름 사이트 링크(2020.01.02 기준 현재 사이트 서버가 죽은 상태다…으아)사실상, 초기 개발 당시 개발자 4명이서 기능 명세를 하면서 개발도 하면서 디자인도 하고 막막 되는대로 개발을 뛰어들어 엉망인 사이트이다.. 그래서 계속 개편을 하고자 했는데 아직까지도 이루어지지는 못하고 있다.그리고 어느 순간, 하나의 웹사이트로 시작한 이 한아름은 하나의 단체가 되었고 현재는 지금 20 명이 넘는 인원이 모여 여러 일을 분담하고 활동하고 있다.(언제나 고마워요! 한아름 여러분)현재 나는 한아름 웹사이트의 개편을 하기 위해 잠시 활동을 쉬고있긴 하다. (하지만 아무것도 하지 않는 건 아니다.)node.js나 vue.js, django를 활용해 코드 리팩토링을 하고 있다. 좀 더 유지보수를 하기 쉽도록 말이다.팀플이 너무 많아..국민대학교 1학년은 너무나 팀플이 많았다.. 넘나 힘든 것..소프트웨어 프로젝트 강의의 프로젝트들아예 강의명이 소프트웨어 프로젝트1, 소프트웨어 프로젝트2이였고 기말고사 기간마다 AD project라는 과제가 다가왔다.첫번째로 소프트웨어 프로젝트1은 간단한(?!) SNS 어플을 제작했다.우리 조의 아이디어는 편의점 SNS 어플을 만들어보자였고 편의점의 음식을 리뷰하고 피드에서 리뷰를 찾아보는 어플을 만들려했다.나는 PHP를 이용해 RESTFUL API와 DB를 구성하는 역할을 담당했고, 다른 팀원이 안드로이드 스튜디오를 이용해 어플을 제작하는 역할을 담당했다.생각보다 괜찮은 어플이 제작됬고 발표 또한 성공적으로 잘 한 것 같다..(아마?)두번쨰로 소프트웨어 프로젝트2는 python의 PYQT5를 이용해 만들어야 했기 때문에 PYQT를 활용한 음악 플레이어 Peachpitch를 개발하게 되었다.peachpitch 깃헙 레포: 링크 SRS, ADS, DDS 등의 문서를 작성하고 개발을 하는 것이 과제였지만 결국.. 선 개발 후 문서 작성을 해버리고 말았다.ㅠㅠㅠ원래는 문서를 작성하고 개발을 하는 것이 목표였지만첫째, 조원과 내가 PYQT5에 대해 아는 것이 전무함.둘쨰, 소스 코드 제작 기간(발표날까지 기간)이 촉박했음.위와 같은 이유때문에 개발을 하고 문서를 작성하게 되었다.아무튼 현재도 계속 이슈가 생기고 버그 fix를 해야 하는 프로그램이지만 구색을 잘 갖추어 만들어진 GUI 프로그램이 되었고 추후에 좀 더 수정을 해봐야 할 것 같다.Xycar와의 악몽2학기 수업 중, 자이트론의 Xycar b2를 활용한 두 강의가 있었다. 바로 창업연계공학설계입문과 유레카 프로젝트이다. 두 강의에 대한 자세한 이야기는 하지 않겠다. 하지만 이 2개의 강의에 엄청 엄청 상상 이상의 시간을 쏟았다.일단 국민대학교에는 소프트웨어학과 공간에는 자율 주행차를 구동할 수 있는 자율 주행 스튜디오가 존재한다. 이 공간에서 계속 돌릴 때마다 결과가 달라지는 Xycar를 붙들고 코딩을 한 기억만이 2학기에 남는 기억이 될 정도로 너무 많은 시간을 쏟았다.아무튼, 학기가 끝나면서 이 악몽에서 이제 탈출했다.2019년에 공부한 것 중 기억에 남는 것들 SQL JOIN문 미워.. JS JS 기본 문법 node.js (계속 하는 중이다..!) Linear Algebra JAVA Python(언어 그 자체,flask, django 등등) Xycar(임베디드 시스템 프로그래밍) Algorithm segment tree Mo’s algorithm KMP Aho corasick 등등 마무리아무튼 말이 너무너무 길었다. 정리가 안 되는 문장도 있고 말이 이상한 문장도 있을 것이다. 2020년이 왔다는 것에 설렘이 가득 찬 동시에 2019년이 갔기 때문에 빠르게 2019년의 회고를 쓰고 싶었다.2020년은 이보다 더 좋은 결과, 일들이 있길 바란다.화이팅" }, { "title": "[BOJ] 1328 고층 빌딩", "url": "/posts/boj-1328/", "categories": "acmicpc", "tags": "algorithm, BOJ, 백준, 백준 온라인 저지, BOJ 1328, PS, CP", "date": "2019-11-13 00:00:00 +0900", "snippet": "1328 고층 빌딩문제문제는 아래 링크에서 확인 BOJ 1328 고층빌딩 문제 풀이이 문제에서 사용되는 알고리즘은 다이나믹 프로그래밍이다.핵심 점화식은D[i][j][k] = (D[i-1][j][k-1] + D[i-1][j-1][k] + (i-2)*D[i-1][j][k]) %Mod이다.하나씩 뜯어서 보자. D[i][j][k]의 의미D[i][j][k] = i개의 건물이 있을 때, 왼쪽에서 j개의 건물이 보이고 오른쪽에서 k개의 건물이 보이는 경우의 수 D[i-1][j][k-1]를 더하는 이유i-1개의 건물이 있을 때, j개의 건물이 왼쪽에서 보이고 오른쪽에서 봤을 때, k-1개의 건물이 보이는 상황을 상상해봅시다.이때, i-1개의 건물들보다 작은 어떤 한 건물이 맨 오른쪽에 추가됬다고 합시다.그러면 왼쪽에서 볼 때는 어차피 안보이기 때문에 j개 그대로 보입니다.반면에 오른쪽에서 볼 때는 제일 작은 i번째 건물이 새로 추가되어 보이기 때문에 k개의 건물이 보이게 됩니다.따라서, D[i-1][j][k-1]은 D[i][j][k]에 포함됩니다. D[i-1][j-1][k]위와 비슷합니다.이번엔 오른쪽이 아닌 왼쪽에 제일 작은 건물 하나가 추가된다고 생각하면 됩니다. (i-2) * D[i-1][j][k]위의 2가지 경우로 제일 작은 i번째 건물이 맨 왼쪽, 오른쪽에 추가되는 경우가 나왔습니다.그러면 당연히 이제 중간에 추가되는 경우입니다.i-2는 추가될 수 있는 위치의 개수입니다.(i-1개의 건물이 있을 떄, i-2 곳에 건물을 배치할 수 있습니다.)그러면 이제 왜 건물을 중간에 위치하는데 D[i-1][j][k]를 곱하느냐만 알면 됩니다.한번 제일 작은 건물을 추가한다는 것에 집중해봅시다.제일 작은 건물을 기존 건물들 사이에 집어넣은다고 생각하면,어차피 제일 작은 건물은 기존 건물들에 가려져 안보입니다.따라서, 제일 작은 건물을 추가해도 당연히 왼쪽, 오른쪽에서 보이는 건물의 개수가 변하지 않기 때문에 (i-2)에 D[i-1][k][k]를 곱하면 된다는 얘기가 됩니다.문제 코드pythonD = [[[0]*110 for i in range(110)] for j in range(110)]N,L,R = map(int,input().split())D[1][1][1] = 1Mod = 1000000007for i in range(2,N+1): for j in range(1,L+1): for k in range(1,R+1): D[i][j][k] = (D[i-1][j][k-1] + D[i-1][j-1][k] + (i-2)*D[i-1][j][k]) %Modprint(D[N][L][R])오늘의 잡소리처음에 이 문제를 봤을 때, 이걸 어떻게 풀지라는 생각을 했고 고민을 좀 많이 했습니다.살짝의 힌트를 얻으려고 다른 분들의 풀이를 살짝만 보자하고 봤었습니다.문제는 풀이가 되게 짧았고 그게 바로 핵심이었고 강렬한 스포를 당해 문제를 푸는 것이 싱겁게 되었습니다..ㅋㅋㅋ" }, { "title": "대학교 새내기의 2019 ACM-ICPC 후기", "url": "/posts/acmicpc-2019/", "categories": "acmicpc", "tags": "algorithm, acmicpc, ACM-ICPC, 대학생 알고리즘 대회", "date": "2019-10-06 00:00:00 +0900", "snippet": "첫 ACM ICPC 후기너무나 미숙했고 부족했다.팀원과의 호흡을 맞추는 시간도 부족했고, team note도 제대로 준비하지 못했다..그리고 대회를 시작한 직후, DomJudge 서버의 과부화가 왔는데 이때 I. Registeration을 제출하는 과정에서내가 계속 새로고침을 눌렀는데 이게 오히려 제출을 늦게 되게 만들었던 것 같다..ㅠㅠ최종 스코어보드(in 국민대학교)우리 팀명은 1ggondae2zzolbo 였다.팀원끼리 회의를 하다가 1명의 선배와 2명의 새내기가 있어서 이런 팀명을 하자고 얘기가 나왔고 그대로 이름을 짓게 되었다.최종 스코어보드를 보고 든 생각국민대학교에서는 3학년 전공 수업인 알고리즘에서 ACMICPC 대회를 나가게 한다. 그래서 그런지 내 전공 수업 때 계시는 조교님, 잘 아는 선배들이 대회장에 되게 많이 계셨다. 그 와중에도 중간 스코어보드가 fix된 상황에서 우리 팀이 3등이었던건 선전했다고 생각했고 최종 순위가 5등인게 아쉽긴 하지만 내년엔 다를 것이다.(이제 감 잡았다.)푼 문제 풀이,못 푼 문제의 접근 방법푼 문제가 많지 않다..ㅠㅠ일단 쭉 적어본다. 순서는 내 마음대로다.I. RegisterationDom Judge의 아이디와 비밀번호를 출력하면 된다.제작년, 작년 ACMICPC 후기들을 읽고미리 팀노트에 적어가서 바로 하였다.H. Four Squares50000까지의 제곱수는 아마 232개쯤 된다고 계산이 되었고 DP 배열에 i를 구성하는 제곱수의 최소 개수를 저장하는 방식으로 해결했다.시간 복잡도 : O(n*(sqrt(n)))C Byte Coin개인적으로 이 문제가 제일 아쉬운 문제이다.Dom Judge의 상태만 좋았다면 제대로 풀 수 있었을 것 같다.먼저, 내가 그냥 이거 브루트 포스로 다하면 되지 않냐고 했고 코드를 구현해서 제출했지만 TLE..그래서 미적분의 극대,극소 부분 그 점일때 사고 파는 식의 구현을 했지만 일부 예외 테케를 대회가 끝나고 알게 되었다.(심지어 이 코드가 틀렸다는 것을 대회 서버의 채점이 늦어져 대회가 끝나고 알게 되었다.)D. Cancal뭔가 그냥 하면 풀릴 것 같은 문제였지만 이문제를 해석하고 풀이를 시작하게 된 시간이 너무 늦어서 풀기 힘들었고 어떻게 할까 생각하다가 끝났다..B. Balanced String이 문제는 처음에 선배가 해석을 하였고 내가 설명을 들었다. 근데 나는 보자마자 바로 DP라고 생각을 했도 너무나도 잘 들어맞았다. 바로 종이에 DP식을 쓴 뒤, 선배에게 구현을 맡기고 다른 문제를 풀기 시작했다. 살짝 선배와 생각이 달랐는지 구현이 몇개 잘못되어있는 것을 나중에 보고 일부 고친 뒤, 제출해 AC 되었다.시간복잡도: O(n)F. Dryer이 문제는 처음부터 끝까지 내가 집착한 문제이다.풀 수 있을 것 같았다. k가 1부터 3이길래 쉽다고 생각했다. 하지만 k가 3일 때, 너무나 HELLPARTY가 생기는 걸 보고 다른 문제를 푸는 것에 더 집중했다..G. Enumeration솔직히 너무나 간단한 문제라 생각하고 접근했지만문제를 잘못 읽었었다. 아직도 이 문제의 정확한 의미와 풀이를 모르겠다..E. Choreography팀원 모두가 포기하고 넘긴 문제이다. 다들 미숙해서 이 문제의 해석부터 포기했다..(시간이 너무나 부족하다고 여겼다.)정리솔직히 너무나 아쉬운 대회 내용이었다.올해 겨울은 인턴을 하러 회사를 가지 말아야겠다는 생각이 들었다.. 겨울에는 좀 알고리즘 공부를 더 빡세게 하고 와야 본선을 가볼 수 있지 않을까..ㅜㅜ아, 만약 이 글을 국민대학교 분이 읽는다면 이거 하나 알려드립니다. 팀원 구합니다^^.(팀원이었던 선배가 대학원에 가십니다..)" }, { "title": "본인 방금 소프트웨어 특기자되는 상상함.(2)", "url": "/posts/mentoring-02/", "categories": "class", "tags": "소프트웨어학과, SW, 소프트웨어 특기자, 학생부 종합", "date": "2019-09-15 00:00:00 +0900", "snippet": "프로그래밍을 해보고 싶다고요?먼저 기초 100제를 푸세요.codeup.kr에 올라와 있는 기초 100제로 시작해보세요. 링크언어는 C언어로 해봅시다.제가 기초 100제로 코딩을 시작해서인지는 모르겠지만 기초 100제가 정말 프로그래밍을 시작할 때, 해보면 좋은 문제들로 구성되어 있다고 생각합니다.oj 사이트 활용를 활용합시다.진짜 oj 사이트는 너무 많고 많습니다.(사실 저도 oj 사이트 만들 생각이지만 너무나 oj 사이트 만들기 어렵네요…ㅜㅜ) 제가 알고있는 oj 사이트들입니다. https://codeup.kr/index.php https://programmers.co.kr/ http://koistudy.net/ https://www.acmicpc.net/ (soved.ac 를 같이활용하는 것을 추천드립니다만..화이트리스트 목로겡 포함되셔야 합니다..ㅜㅜ) http://hmcoder.kr:8080/ (한민고 OJ입니다.) http://www.jungol.co.kr/ http://codingfun.net/onlinejudge/ https://leetcode.com/이건 추가로 온라인 알고리즘 대회가 열리는 사이트 목록입니다. https://codeforces.com/ https://www.sundaycoding.xyz/ https://arena.topcoder.com/#/u/dashboard https://www.hackerrank.com/contests https://www.oncoder.com고등학교 알고리즘 대회 및 프로그래밍 대회뒤늦게 알고리즘에 고여가는 사람의 팁고등학교 알고리즘 대회의 요즘 메타는 빡센 내용을 구현하거나 수학 실력이 뛰어나야 풀 수 있는 문제보다는학생이 정말 이 문제에 대해서 깊은 생각을 하고 문제를 해결할 수 있는가를 보는 것 같습니다.따라서, 평소에 알고리즘 문제를 풀어볼 때, 앞선 글에서 말했듯이 끝없이 질문하는 습관을 가지시는게 좋을 것 같습니다.그래도 일단 진짜진짜 적어도 아래에 있는 알고리즘들은 공부해보시는 걸 추천합니다. counting sort quick sort Dynamic Programming (복잡한 것 까지는 아니어도 개념이라도..) 이분 탐색 DFS / BFS (이거는 진짜 능숙하게 다루셔야 합니다.) Greedy Algorithm (탐욕 알고리즘, 탐욕적이다는 게 뭔지에 대해서 알고 있는게 좋습니다.) 최단 거리 알고리즘 최소 신장 트리 (Minimum spanning Tree) 에라토스테네스의 채 비트마스크이 알고리즘들은 시간이 되거나 좀 더 어려운 걸 풀어보고 싶으시다면 도전해보세요. LIS (O(n^2) 방식과 O(nlogn) 방식 2가지 모두) 볼록 껍질 네트워크 플로우 이분 매칭 세그먼트 트리 평방분할 알고리즘 Disjoint-Set 우선순위큐를 활용한 다익스트라 알고리즘 냅색 CCW CC(Coin change) 세그먼트 트리 with Lazy Propagation 단절점(AP) LCA추천하는 커리큘럼(계속 수정 될 예정입니다.)아래의 그래프는 C++ 기준으로 작성되었습니다.(ACM-ICPC, 정보올림피아드 등등의 대회에서 주로 C++로 문제를 해결하기 떄문입니다.) " }, { "title": "본인 방금 소프트웨어 특기자되는 상상함.", "url": "/posts/mentoring-01/", "categories": "class", "tags": "소프트웨어학과, SW, 소프트웨어 특기자, 학생부 종합", "date": "2019-09-15 00:00:00 +0900", "snippet": "서론미리 말씀드립니다.이 글은 09.27일에 진행되는한민고등학교 X 한아름 멘토링에서 사용되는 자료이며필자의 주관적인 생각이 매우 많이 담겨 있는 글입니다.따라서, 아 이런 idea와 생각을 하는 사람이 있다고 생각해주시고무조건 받아들이지는 마시기 바랍니다.소개국민대학교 소프트웨어학부 김신건 2016.03 한민고등학교 입학 2017 한민 학술제(발표 부문) 금상(1위) 2017 한민 학술제(발표 부문) 은상(2위) 2017 제 5회 한국로보컵오픈대회 Soccer Light Weight 부문2위 2017 Robocup 机器人世界杯中国赛华南公开赛 三等奖 2017 제 1회 한국로보컵코딩대회 RescueLine Secondary 부분 Best Research Award 2018 ICT 어워드코리아 이산수학 고등부 장려상 2018 제 3회 국민대학교 알고리즘 대회 장려상 2019.01 한민고등학교 졸업(3기) 2019.02 국민대학교 입학(소프트웨어 특기자 전형) 2019 국민대학교 두리톤 장려상 2019.07.~ Grepp 알고리즘 컨텐츠 제작자 (인턴) 2019.09 ~ 구로고등학교 융합형 프로그래밍 강좌 강사목차1.소프트웨어 학과 1-1. 소프트웨어 학과는 뭐하는 학과인가요 1-2. SW학과, 단지 호기심만으로만 가도 되나요? 1-3. 특기자 전형 1-3-1. 자신에게 맞는 전형은 스스로 공부해보세요. 1-3-2. 특기자 전형 1-3-3. 저의 이야기 &amp;amp; 특기자 전형 준비2. 프로그래밍을 해보고 싶다고요? 2-1. 기초 100제를 푸세요. 2-2. oj 사이트 활용방법3. 고등학교 알고리즘 대회 및 프로그래밍 대회 3-1. 뒤늦게 알고리즘에 고여가는 사람의 팁 3-2. 추천하는 커리큘럼소프트웨어 학과소프트웨어 학과는 뭐하는 학과인가요? 국민대학교 커리큘럼 국민대학교 SW 사이트 대학교마다 다르겠지만 주로 1,2학년 때는 기초적인 프로그래밍 언어, 알고리즘, 자료 구조 등의 기초 지식을 쌓습니다. 그리고 3,4학년 때는 프로젝트 진행 또는 쌓아둔 기초 지식을 원없이 발휘할 수 있는 심화적인 내용을 다룹니다.국민대학교의 경우, 1,2학년때는 기초적인 내용들을 배우고 3,4학년 때는 자신이 선택한 트랙에 따라 심화 내용을 공부합니다.1. 논리적인 사고와 문제 해결 능력, 설계 능력들을 기른 뒤, 이를 프로그래밍으로 해결하는 방법을 배웁니다.2. 소프트웨어 학과는 컴퓨터를 고치는 학과도, 컴퓨터 사양을 맞추는 학과도, 엑셀-파워포인트 등을 배우는 학과도 아닙니다.3. &quot;소프트웨어 학과가면 게임같은 거 만드는 거 아냐?&quot; 라는 말은 맞지만 게임&#39;만&#39; 만드는 게 아닙니다. 인공지능, IOT, 게임, 미디어, 임베디드 등등 많은 것을 배우고 실습합니다.SW학과, 단지 호기심으로만 가도 되나요?솔직히, 단지 호기심만으로 접근하기에는 어려운 학과이지 않을까 생각합니다.실제로, 제 친구들 중에 SW 학과에 들어와서 코딩을 접하는 친구들도 있습니다.하지만 처음에 프로그래밍의 프자도 모르는 자신을 보며 회의감을 가지기도 하고 학과 공부를 포기하기도 합니다.그래서 저는 아직 고등학생인 여러분에게 한번이라도 프로그래밍 언어라든지, 논리적인 사고를 하는 방법등을 한번씩 공부해보길 바랍니다.여기까지 설명을 하다보면 이런식으로 나뉘게 됩니다.프로그래밍 언어 공부하는 것도 재밌고, 논리적으로 생각하는 것도 좋아!꼭 SW학과 오셔서 자신의 기량을 펼쳐 주세요.난 프로그래밍 언어 같은 건 모르겠고 뭔가 논리적으로 생각하는 게 좋은데?프로그래밍 언어를 하나만 공부해보면서 자신의 생각을 표현해보세요. 어느 순간 빠져 있을 겁니다.난 둘 다 하기 힘들 것 같은 데, SW 학과는 가고 싶어.SW 학과를 오시고 싶으시다면 언젠가 겪어야 할 일입니다. 화이팅..!ㅠㅠ…아무튼 결론을 내려보겠습니다.SW학과에 단순 호기심을 오기보다는 자신의 흥미, 능력, 사고 등등 여러가지를 고려해보세요.그리고 한번 프로그래밍 언어, 알고리즘 등등도 공부해보면서 자신에게 맞는지 확인해보세요.모든 것을 고려해보고 괜찮을 것 같다면 SW학과, 무조건, 꼭, 오시길 바랍니다.특기자 전형자신에게 맞는 전형은 스스로 공부해보세요.제목이 너무 직설적일 수도 있습니다.하지만 이는 너무나 저에게는 뇌리에 박혀있는 생각입니다.사람마다 가지고 있는 생각, 능력, 스펙, 성적, 상장의 종류, 상장의 수, 학생부의 내용, 내신 뭐 다 다를 수 밖에 없고 자신이 바라보고 있는 대학 또한 다 다릅니다. 근데 &quot;이전에 이런 사람이 이렇게 갔다더라&quot;, &quot;이렇게만 하면 어디 대학 갈 수 있어&quot; 와 같은 선배 혹은 부모님, 선생님의 말만 듣고 자신의 생각없이 자신의 미래를 정할 건가요?직접 가고 싶은 대학교 목록을 정하고 대학교 입학처 사이트 들어가서 입학 전형 목록, 선례, 이전 입학 성적 등등 다 찾아가면서 입학 전형 한번씩 정리해보세요. 그렇게 하다보면 자신에게 맞는 대학교, 목표가 정해지고 그걸 향해 달려가면 됩니다.특기자 전형소프트웨어 특기자 전형, 참 말이 많은 전형입니다..SW 특기자 전형을 꿈꾸는 학우 여러분들을 위하여 (이 분의 글을 보고 저의 생각을 좀더 첨가해봤습니다.)특기자 전형은 학종의 미묘한 연장선입니다.특기자 전형은 참 애매합니다. 어떤 대학교는 학생부 종합과 거의 똑같고, 어떤 곳은 완전 다르게 진행되기도 합니다. 예를 들어, 제가 입학한 국민대학교의 소프트웨어 특기자(2019입학기준)의 경우, 1차 전형이 교외 상장 1개로 결정되고 2차 전형의 경우 면접의 비율이 압도적으로 높았습니다.이렇게 학종과 관련없이 진행되는 학교도 있고 학종과 거의 똑깥이 진행되는 학교가 있기 때문에 미묘하다라는 말을 하게 되었습니다.따라서 앞서 말했듯이 자신에게 맞는 전형을 찾다보면 특기자 전형을 넣을만 한 곳이 있고, 특기자 전형으로 넣으면 안되는 곳이 있습니다.(계속 반복해서 말하게 되는 것 같네요.) 그래서 스스로 전형을 공부하고 자신에게 맞는 전형이 특기자 전형이라고 생각하신다면 차근 차근 준비하시면 될 것 같습니다.저의 이야기 &amp;amp; 특기자 전형 준비저는 SW특기자 전형(대학마다 이름이 조금씩 다르지만 통일해서 말하겠습니다.)으로 4개 학교에 지원했습니다.(나머지 2장은 학종이었습니다.)1. 성균관대학교2. 한양대학교3. 경희대학교4. 국민대학교다른 학교들은 확신이 없었지만 국민대학교는 확신을 가지고 지원을 한 것 같습니다. (제가 지금 국민대학교에 있어서 그렇게 기억이 왜곡된 걸 수 도 있습니다..ㅋㅋ)그 이유는 위에서 말했듯이 국민대학교의 입학전형이 저한테 매우 유리했기 때문입니다. 저는 2018년 국민대학교 알고리즘 대회에서 장려상을 받은 상태였고 이 상은 국민대학교 입학 전형에 매애애애애우우우 크게 반영되는 상이었습니다.일단 그렇게 원서를 다 작성하고 수능을 봤습니다.수능 80일 전까지 프로그래밍에 빠져있었던지라 수능 점수를 기대는 하지 않았습니다. 그래도 6월 모평 때, 수학을 4등급을 맞으니 멘탈이 나갔습니다. 그리고 다시 모의고사, 수능 공부를 하기 시작했고 수능에서는 수학을 89점 맞았고 다른 과목들도 다 괜찮게 받은 것 같았습니다.하지만 역시나 역대급으로 HELL을 보여준 국어가 저의 발목을 붙잡았고 정시 원서를 쓸 미련을 바로 버리게 만들었습니다.그렇게 이틀 뒤, 국민대학교 특기자 면접을 보게 됩니다.(수능 이틀전에 1차 합격을 본 상태였습니다.)특기자 면접에서는 제가 준비해간 포트폴리오 위주의 면접이었고 여러 질문들을 받았습니다.(면접 후기를 적어논 한글 파일 또는 프린트 참고해주세요!!)딱 이 면접에서 붙은 것을 확신한 것은 여러 말 중 &quot;국민대학교 와서 이거 연구해봐요&quot; 와 &quot;학원 다닌적 있어요?&quot; 였습니다. 그 당시에 확신한 이유는 저는 학원을 다닌 적도 없으며 스스로 공부했었고 제가 하고자 하는 연구 내용을 들으시고 너무나 흐뭇하게 보고 계셔서 인 것 같습니다.면접이 끝나고 나서 몇 일동안, 다른 대학들의 불합격 통보를 수없이 보게 되었고.. 몇 일 뒤, 국민대학교 특기자 최초합을 받고 국민대학교에 입학하게 되었습니다.이제 제가 직접 특기자 전형을 경험하고 준비하면서 했던 내용을 바탕으로 준비하는 과정을 정리해보겠습니다!!1. 내신 버리지 말자내신이 심각하게 중요한 전형이 아니더라도 챙겨야 합니다. 내신이 엄청 하위권인데 특기자 전형을 붙은 case는 이미 정보과학에서 ‘괴물’, ‘괴수’ 라고 불리는 사람들입니다. 스스로 자신이 괴물, 괴수가 될 자신이 있으시다면 제 말 듣지 않으셔도 될 것 같습니다.(괴물이 된다는 것은 정올, 각종 알고리즘 대회에서 끊이지 않고 상을 타고, codeforeces나 boj같은 알고리즘 사이트의 탑을 먹는 것입니다.)2. 자신이 공부한 내용을 정리하세요.자신이 알고리즘이든 수학이든 배운 내용에 대해서 github 블로그, 티스토리, 네이버 블로그 등등 아무데나 일단 정리하는 습관을 가지시길 바랍니다.언젠가는 쓸 일이 무조건 있을 겁니다. 학생부 기록할 때 특기자 포트폴리오 작성 대회 준비 등등3. 알고리즘에 끝없이 질문해보세요.어떤 알고리즘을 공부한다면 계속 스스로 질문을 해보세요. “만약 이런 상황이라면 어떻게 해야되지?” 예를 들어, N개의 숫자가 나열되어 있을 때, N개의 숫자를 합하는 문제를 풀었다고 생각합시다. 아래와 같이 이런 여러 가지의 질문을 할 수 있습니다.“만약에 N개의 숫자 중에 일부 숫자만 더한 값을 구하려 할 때, 어떻게 하면 빨리 구할 수 있을까?”“만약에 일부 숫자들이 변할 수 있는 상황에서 N개의 숫자의 합을 어떻게 하면 쉽게 구할 수 있을까?”“만약에 일부 숫자들이 변할 수 있는 상황에서 K개의 숫자의 합을 여러번 구하려면 어떻게 해야 할까?”…4. 알고리즘 대회를 나갔다고요? 정리하세요.저도 잘 지키지 못했던 내용이지만 정말정말 필요한 것입니다. 알고리즘 대회를 나간 뒤에는 자신이 푼 문제와 못 푼 문제에 대해서 정리하세요. 만약 못 푼 문제를 계속 모르고 지낸다면 영원히 그 문제는 못 푸는 문제가 되는 것입니다. 아는 문제였더라도 내가 어떤 알고리즘, 생각으로 문제를 풀었는지를 정리해야 합니다. (대회에서 즉석에서 떠오른 아이디어가 정말 맞는건지 점검하는 것도 실력을 늘리기에 정말 좋은 것입니다.)5.소논문 한번 써보실래요?한번이라도 자신이 불편함을 느낀 부분이 있다면이를 해결하려는 프로그램이나 알고리즘을 구상해서 소논문을 작성해보세요. 정말정말 소중한 경험이 되고 나중에 써먹기 좋은 포트폴리오가 됩니다.6. 친구들과 프로젝트를 진행해보세요.뜻이 맞는 친구가 있거나 다른 분야를 꿈꾸는 친구라도 분업을 한 뒤, 프로젝트를 진행해보세요. 다 같이 한다는 생각때문에 포기를 하지 않고 열심히 할 수 있게 될 뿐만 아니라 자신의 실력도 금방 늘 수 있는 길이었던 것 같습니다.7. 정말 자신이 알고있는 내용만 포트폴리오에 포함시키세요.가끔 자신이 알고있는 내용이 아닌데 일단 포트폴리오, 자소서, 생기부에 포함시키는 친구들이 있습니다. 물론 운 좋게 넘어가는 경우도 있지만 그런 내용 하나하나 때문에 면접에서 큰코 다칠 수 있습니다. 만약 자신이 대충 알고 있거나 모르는 내용인데 포트폴리오에 포함된 경우, 면접관이 너무나 잘 알아챕니다. 괜히 양 늘릴려고 질을 낮추지 마세요.8. 특기자 전형은 고여있습니다.특기자 전형을 준비하기 위해 여러 알고리즘 대회를 다녀보면, 어디서 많이 본 이름들이 보입니다. 계속 같은 사람들끼리 경쟁한다는 얘기입니다. 정말 여러분이 알고리즘 대회 수상으로만 특기자 전형을 지원하고 싶으면 계속 만나게 되는 사람들과 경쟁해야 합니다. 설렁설렁 이정도 하면 되겠지하는 마음가짐은 안됩니다. 당신도 고인물이 될 각오하시길 바랍니다.(진짜 알고리즘 대회 수상만으로 특기자 전형을 준비하는 사람에 한해서 입니다.)9. 알고리즘과 자료구조 공부는 최대한 풀어서 생각하세요.만약 알고리즘과 자료구조를 들어보지 못했거나 잘 모른다면, 예를 들어드리겠습니다.배가 고파서 오므라이스를 먹으려 합니다.이때, 필요한건 오므라이스를 만드는 레시피, 재료, 조리기구등이 있겠죠?오므라이스를 만드는 레시피 = 알고리즘재료 = 어떤 input data조리기구 = 자료구조오므라이스를 만드는 데 프라이팬이라는 자료구조를 쓴다면 오므라이스를 만드는 알고리즘이 쉽게 작동하겠죠?만약 오므라이스를 만드는데 냄비라는 자료구조를 쓴다면 오므라이스를 만드는 알고리즘이 비교적 어렵게 작동하겠죠?이런 식으로, 어떤 명령들이 순서대로 주어지면 알고리즘, 알고리즘을 구현하기 위해 도와주는 무언가를 자료구조라고 이해하시면 될 것 같습니다.이제 본 얘기로 돌아와 보겠습니다.위의 예시처럼 알고리즘과 자료구조 공부는 최대한 자신에게 이해가 가는 방법으로 풀어서 공부해보세요.알고리즘과 자료구조는 그 어떤 코드를 말하는 것이 아닙니다. 알고리즘과 자료구조는 사람의 생각이고 idea입니다. 최대한 자신에게 맞는 idea를 찾아보세요. 그럼 자연스럽게 코드가 따라오게 됩니다.긴 글 읽어주셔서, 긴 말 들어주셔서 감사합니다.다음 내용은 다음 post에 올리도록 하겠습니다!" }, { "title": "PS를 하면서 사용하는 python input() 방식", "url": "/posts/python-input/", "categories": "class", "tags": "python", "date": "2019-09-08 00:00:00 +0900", "snippet": "python의 input()은 문자열이야!python에서 input()을 사용할 떄 다음과 같이 이해하면 편하다.input()에 사용자가 입력하는 내용이 문자열로 대치된다.이해가 안될 수 있으니 예시를 들어보자.a = input()print(a)위와 같은 코드가 있을 때, 사용자가 Hello라는 문자열을 입력했다고 생각해보자. 그러면 아래 코드와 같이 바꾸어 생각해볼 수 있다.a = &quot;Hello&quot;print(a)말 그대로 input()의 위치에 사용자가 입력한 문자열이 들어가는 것이다. 그러면 한번 5를 입력하고 2를 곱한 값을 출력해보자.a = input()print(a*2)만약, 위의 코드에 입력을 5라 했을 때, 10이라는 답이 출력되길 바랬다면 아직 python의 input()을 완벽히 이해하지 못한 상황이다.python의 input()은 문자열로 생각해야 한다.따라서 위의 코드는 55라는 문자열이 출력됬을 것이다. 그렇다면 10이 출력되게 할려면 어떻게 해야 할까.a = input()a = int(a)print(a*2)이렇게 문자열을 int() 함수를 이용해 정수로 바꾼 뒤, 2를 곱한 다면 10이 출력될 것이다.이 정도 내용을 모두 이해했다면 input()의 방식을 어느 정도 이해했을 것이다. 다음으로 넘어가보자.PS문제에서 주로 입력이 들어오는 방식숫자 한 개a = int(input())두 줄에 걸쳐 숫자 2개a = int(input())b = int(input())한 줄에 걸쳐 숫자 2개a,b = map(int,input().split())한 줄에 걸쳐 N개의 숫자L = list(map(int,input().split()))한 리스트에 담아 인덱스로 접근하는 것이 더 편하지만, 인덱스에 따라 무슨 정보가 담기는 지 잘 기억해야 한다.특수 기호로 구분된 N개의 숫자L = list(map(int,input().split(&quot;특수기호&quot;)))문자열 1개a = input()공백이 포함됬든 안 포함됬든 상관없이 개행문자 기준으로 한 줄 모두 입력된다.문자열 2개a,b = input().split()문자열 N개L = list(map(int,input().split()))실수 1개a = float(input())사실, 필자는 부동소수점 오류때문에 float으로 변환하기보다 input() 문자열 그 자체로 계산을 한 뒤, 직접 소숫점을 출력하는 방식을 더 많이 사용한다.실수 2개a,b = map(float,input().split())일단 여러 부류로 나누어 설명을 해보았다. 더 많은 내용을 정리해 조금씩 더 정리를 해보겠다.2019.09.08) 일단 정수, 문자열, 실수에서 나올 수 있는 예시 정도를 정리해보았다." }, { "title": "python 출력", "url": "/posts/python02/", "categories": "class", "tags": "python", "date": "2019-08-28 00:00:00 +0900", "snippet": "python 출력파이썬에서 출력을 하는 방법은 너무나 간단합니다.바로 print() 함수를 사용하는 것입니다.물론 다른 명령어가 있긴 하지만 print()를 주로 사용합니다!바로 아래 명령어를 실행시켜봅시다.(Python IDLE 이든, Python 3.X 이든, 개인 IDE이든 상관없이 일단 실행해봅시다!)print(&quot;Hello World!&quot;)뭔가 print() 에서 () 괄호 안의 내용을 출력하는 것 같죠?이번엔 아래 명령어도 실행시켜볼까요?print(1+1)어? 이번엔 1+1을 그대로 출력하는게 아니라 1+1의 결과인 2를 출력하네요한번 그러면 실수도 계산해볼까요?print(3.14+3.14)3.14+3.14의 답인 6.28을 출력해주네요.이번엔 복소수도 계산해볼까요?(python에서는 허수i를 j로 표기한답니다.)print((3+4j)+(5+7j))위의 코드를 실행시키면서 우리는 자연스럽게 파이썬의 print, 문자열, 정수, 실수, 복소수를 경험해볼 수 있었습니다. 한번 정리해봅시다.정리 print() 함수는 괄호 안의 무언가르 출력해주는 역할을 합니다. “Hello World!”와 같이 “내용” , ‘내용’ 처럼 따옴표로 둘러싸인 것은 문자열이라 합니다. print(1+1)을 했을 때, 2가 출력된 이유는 1+1이 문자열이 아닌 정수 연산이었기 때문입니다. 따라서 print(“1+1”) 을 해보면 1+1로 출력이 됩니다!" }, { "title": "알고리즘 공부를 하는데 왜 자료가 없니..", "url": "/posts/thinking/", "categories": "thinking", "tags": "algorithm", "date": "2019-08-22 00:00:00 +0900", "snippet": "계기이 글은 단지 내 사소한 하소연이다.최근에 BOJ (www.acmicpc.net) 사이트의 문제를 풀고여러 알고리즘을 접하게 되었다. 아래는 최근에 내가 접하거나 다시 공부한 알고리즘이다. Segment Tree Segment Tree with Lazy Propagation Mo’s Algorithm sqrt decomposition Bipartite Matching Network Flow etc..근데 공부하는데 진짜 애먹은 것 같다.하소연알고리즘 공부를 하는데 좀 더 심화적이고 더 재밌는 내용들은 한글자료가 적을까라는 생각이 너무나 많이 들었다. 자료가 없다는 것이 아니다. 여러 사람이 다루지 않는다는 것이다. 알고리즘이라는건 사람의 생각을 담아논 것이다. 나는 알고리즘은 자고로 여러 사람의 생각과 설명을 봐야 좀더 좋은 이해를 할 수 있다고 생각한다.뭔가 이상한 결론아무튼 이렇게 된 김에 영어자료든 한글자료든 모으고 공부해서 직접 자료를 만들어볼 생각이다. 실력이 뛰어나지 않아도 한 사람의 생각이라도 정리가 더 된다면 점차 여러 사람이 나처럼 나서지 않을까라는 생각이 들었기 떄문이다." }, { "title": "python tutorial", "url": "/posts/python01/", "categories": "class", "tags": "python", "date": "2019-08-22 00:00:00 +0900", "snippet": "프로그래밍파이썬(Python)위의 로고는 현재 여러 분야에 사용되는 프로그래밍 언어, 파이썬의 로고입니다.파이썬은 1991년, 귀도 반 로썸(위의 인물 사진) 발표한 언어입니다.파이썬을 사용하는 이유단순함 문법이 단순합니다.효율성 코드가 단순해 파이썬 코드를 작성하는 코드의 속도가 빨라 효율적입니다.배우기 쉬움 프로그래밍을 처음 접하는 사람도 쉽게 배울 수 있는 언어입니다.가독성 다른 언어와 비교할 때, 코드를 이해하는게 더 수월합니다.확장성 여러 분야에 사용됩니다. 게임, 인공지능, 통계, 수학, 자연과학파이썬 설치 파이썬 설치 링크설치순서는 다음과 같습니다.1) 아래 체크박스 2개를 다 체크해주시고 Install Now를 눌러주시면됩니다.2) 설치 진행하시면 됩니다.아나콘다 설치아나콘다 설치 링크 컴퓨터의 OS에 맞추어 설치해주시면 됩니다. (python 3.X.X 로 설치해주셔야 합니다.)설치 순서는 다음과 같습니다.1) Next2) Agree3) Just Me 선택4) 기본으로 뜨는 경로로 해주시면 됩니다. Next5) 아래의 체크박스만 체크하고 넘겨주세요.6) 설치중 화면7) 설치 완료아래 사진과 같이 뜨면 설치된 것입니다.간단한 python 실습간단하게 python 실습을 해보겠습니다.아래의 사진과 같이 있을떄, python 3.7을 실행시켜봅시다.아래와 같이 한 검은 창이 뜹니다.한번 1+1을 python으로 계산해봅시다.답이 2라고 나옵니다.이번엔 11111111111111111 x 1231231231261231321가 뭔지 계산해봅시다.답이 13680347014013681207640974304307631라고 나옵니다.이번엔 Hello World를 python으로 출력해봅시다.다음 시간부터 python에 대해 더 자세히 다루어보겠습니다." }, { "title": "Hello World", "url": "/posts/first-post/", "categories": "etc", "tags": "github", "date": "2019-06-27 00:00:00 +0900", "snippet": "Hello World!Hello GitHub Blog" } ]
